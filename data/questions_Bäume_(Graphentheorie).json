{
  "meta": {
    "title": "Bäume in der Graphentheorie",
    "created": "19.11.2025",
    "modified": "19.11.2025",
    "target_audience": "Anfänger",
    "question_count": 40,
    "difficulty_profile": {
      "leicht": 12,
      "mittel": 20,
      "schwer": 8
    },
    "time_per_weight_minutes": {
      "1": 0.5,
      "2": 0.75,
      "3": 1.0
    },
    "additional_buffer_minutes": 5,
    "test_duration_minutes": 35,
    "language": "de"
  },
  "questions": [
    {
      "question": "1. Wie wird ein Baum in der Graphentheorie grundlegend definiert?",
      "options": [
        "Ein Baum ist ein gerichteter Graph mit genau einem Zyklus.",
        "Ein Baum ist ein ungerichteter, zusammenhängender und zyklenfreier Graph.",
        "Ein Baum ist eine Sammlung von Knoten ohne Kantenverbindungen.",
        "Ein Baum ist ein Graph, bei dem jeder Knoten mit jedem anderen Knoten direkt verbunden ist.",
        "Ein Baum ist ein Graph, der mindestens zwei getrennte Komponenten besitzt."
      ],
      "answer": 1,
      "explanation": "Ein Baum ist definiert als ein ungerichteter Graph, der sowohl zusammenhängend ist (jeder Knoten ist erreichbar) als auch keine Kreise (Zyklen) enthält.",
      "weight": 1,
      "topic": "Definition & Eigenschaften",
      "konzept": "Baum-Definition",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Zusammenhängend": "Ein Graph ist zusammenhängend, wenn es zwischen jedem Paar von Knoten einen Pfad gibt.",
        "Zyklus": "Ein geschlossener Pfad in einem Graphen, bei dem Start- und Endknoten identisch sind.",
        "Ungerichtet": "Kanten haben keine Pfeilrichtung; die Verbindung gilt in beide Richtungen."
      }
    },
    {
      "question": "2. Welcher Zusammenhang besteht zwischen der Anzahl der Knoten $n$ und der Anzahl der Kanten $e$ in einem Baum?",
      "options": [
        "Die Anzahl der Kanten ist immer gleich der Anzahl der Knoten ($e = n$).",
        "Es gibt halb so viele Kanten wie Knoten ($e = n / 2$).",
        "Ein Baum mit $n$ Knoten besitzt genau $n - 1$ Kanten.",
        "Die Anzahl der Kanten ist immer um eins höher als die der Knoten ($e = n + 1$).",
        "Es gibt keinen festen mathematischen Zusammenhang zwischen Knoten und Kanten."
      ],
      "answer": 2,
      "explanation": "Eine fundamentale Eigenschaft von Bäumen ist, dass ein Baum mit $n$ Knoten stets exakt $n - 1$ Kanten besitzt. Dies ist eine hinreichende Bedingung für die Baumstruktur bei zusammenhängenden Graphen.",
      "weight": 1,
      "topic": "Definition & Eigenschaften",
      "konzept": "Kantenanzahl",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Knoten (Vertex)": "Ein Punkt in einem Graphen, der ein Objekt oder einen Datenwert repräsentiert.",
        "Kante (Edge)": "Eine Verbindungslinie zwischen zwei Knoten.",
        "n": "Übliche mathematische Variable für die Anzahl der Knoten."
      }
    },
    {
      "question": "3. Ein Baum besitzt 10 Knoten. Wie viele Kanten muss dieser Baum exakt aufweisen?",
      "options": [
        "8 Kanten",
        "9 Kanten",
        "10 Kanten",
        "11 Kanten",
        "12 Kanten"
      ],
      "answer": 1,
      "explanation": "Da für jeden Baum mit $n$ Knoten gilt, dass er $n - 1$ Kanten hat, muss ein Baum mit 10 Knoten genau 9 Kanten besitzen.",
      "weight": 2,
      "topic": "Definition & Eigenschaften",
      "konzept": "Kantenberechnung",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Berechnung der Kantenanzahl",
        "schritte": [
          "Identifizieren Sie die Anzahl der Knoten $n$, hier gegeben als $n = 10$.",
          "Wenden Sie die Baum-Formel für Kanten an: $e = n - 1$.",
          "Setzen Sie den Wert ein: $e = 10 - 1 = 9$.",
          "Das Ergebnis ist somit 9 Kanten."
        ]
      },
      "mini_glossary": {
        "Baum-Formel": "Der Zusammenhang $e = n - 1$ gilt für alle endlichen Bäume.",
        "Kantenanzahl": "Die Summe aller Verbindungen im Graphen.",
        "Knotenanzahl": "Die Summe aller Objekte im Graphen."
      }
    },
    {
      "question": "4. Was versteht man unter einem 'Blatt' (Leaf) in einem gewurzelten Baum?",
      "options": [
        "Den obersten Knoten des Baumes ohne Eltern.",
        "Einen Knoten, der genau zwei Kinder hat.",
        "Einen Knoten, der keine Kinder besitzt.",
        "Einen Knoten, der genau in der Mitte des Baumes liegt.",
        "Einen Knoten, der mit allen anderen Knoten verbunden ist."
      ],
      "answer": 2,
      "explanation": "Ein Blatt ist ein Knoten am 'Rand' des Baumes, der keine ausgehenden Kanten zu weiteren Kindknoten besitzt. In der Graphentheorie hat er den Grad 1 (außer bei einem Baum, der nur aus der Wurzel besteht).",
      "weight": 1,
      "topic": "Terminologie",
      "konzept": "Blatt-Definition",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Blatt (Leaf)": "Ein Endknoten ohne Nachfolger in der Hierarchie.",
        "Kindknoten": "Ein direkter Nachfolger eines Knotens.",
        "Gewurzelter Baum": "Ein Baum mit einem ausgezeichneten Startknoten (Wurzel)."
      }
    },
    {
      "question": "5. Welcher Begriff bezeichnet den obersten Knoten in einem hierarchischen Baum, der keinen Elternknoten besitzt?",
      "options": [
        "Blatt",
        "Ast",
        "Wurzel",
        "Zweig",
        "Krone"
      ],
      "answer": 2,
      "explanation": "Die Wurzel (Root) ist der Ursprungsknoten eines gewurzelten Baumes. Sie ist der einzige Knoten, der keinen Vorgänger (Elternknoten) hat.",
      "weight": 1,
      "topic": "Terminologie",
      "konzept": "Wurzel-Definition",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Wurzel (Root)": "Der Startknoten eines Baumes, Ebene 0.",
        "Elternknoten": "Der direkte Vorgänger in Richtung Wurzel.",
        "Hierarchie": "Ordnungssystem mit Über- und Unterordnung."
      }
    },
    {
      "question": "6. Gegeben ist ein Pfad von der Wurzel zu einem Knoten $K$: Wurzel $\\rightarrow A \\rightarrow B \\rightarrow K$. Wie groß ist die Tiefe des Knotens $K$?",
      "options": [
        "Tiefe 0",
        "Tiefe 1",
        "Tiefe 2",
        "Tiefe 3",
        "Tiefe 4"
      ],
      "answer": 3,
      "explanation": "Die Tiefe eines Knotens ist definiert als die Anzahl der Kanten auf dem Pfad von der Wurzel zu diesem Knoten. Der Pfad Wurzel-A-B-K besteht aus 3 Schritten (Kanten).",
      "weight": 2,
      "topic": "Terminologie",
      "konzept": "Tiefe bestimmen",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Bestimmung der Knotentiefe",
        "schritte": [
          "Die Wurzel selbst hat die Tiefe 0.",
          "Zählen Sie die Schritte (Kanten) von der Wurzel aus.",
          "Wurzel $\\to$ A (1 Schritt), A $\\to$ B (2. Schritt), B $\\to$ K (3. Schritt).",
          "Die Tiefe von K beträgt somit 3."
        ]
      },
      "mini_glossary": {
        "Knotentiefe": "Abstand eines Knotens von der Wurzel (Anzahl Kanten).",
        "Pfad": "Eine Sequenz von Kanten, die Knoten verbindet.",
        "Kante": "Verbindung zwischen zwei Knoten."
      }
    },
    {
      "question": "7. Was ist ein 'Wald' in der Graphentheorie?",
      "options": [
        "Ein Graph, der viele Zyklen enthält.",
        "Ein Graph, der aus mehreren unzusammenhängenden Bäumen besteht.",
        "Ein Baum mit besonders vielen Blättern.",
        "Ein Baum, dessen Knoten farblich markiert sind.",
        "Ein Synonym für einen binären Suchbaum."
      ],
      "answer": 1,
      "explanation": "Ein Wald ist definiert als ein ungerichteter Graph, der keine Zyklen enthält. Er muss nicht zusammenhängend sein; jede seiner Zusammenhangskomponenten ist für sich genommen ein Baum.",
      "weight": 1,
      "topic": "Terminologie",
      "konzept": "Wald-Definition",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Wald (Forest)": "Menge von disjunkten Bäumen.",
        "Komponente": "Ein zusammenhängender Teilgraph.",
        "Azyklisch": "Frei von Kreisen/Schleifen."
      }
    },
    {
      "question": "8. Welche Datenstruktur wird typischerweise verwendet, um eine Breitensuche (BFS) zu implementieren?",
      "options": [
        "Stack (Stapel)",
        "Queue (Warteschlange)",
        "Array (Feld)",
        "Hash-Tabelle",
        "Linked List (Verkettete Liste) ohne Zusatzlogik"
      ],
      "answer": 1,
      "explanation": "Die Breitensuche (BFS) arbeitet nach dem FIFO-Prinzip (First-In, First-Out), um Knoten Ebene für Ebene abzuarbeiten. Dafür eignet sich technisch eine Queue (Warteschlange).",
      "weight": 1,
      "topic": "Traversierung",
      "konzept": "BFS-Datenstruktur",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "BFS (Breitensuche)": "Traversierung, die erst alle Nachbarn besucht.",
        "Queue": "Datenstruktur nach dem FIFO-Prinzip (wer zuerst kommt, wird zuerst bedient).",
        "FIFO": "First-In, First-Out."
      }
    },
    {
      "question": "9. Sie führen eine Tiefensuche (DFS) auf einem Baum durch. Welches Verhalten beobachten Sie?",
      "options": [
        "Der Algorithmus besucht zuerst alle Knoten der Ebene 1, dann Ebene 2.",
        "Der Algorithmus folgt einem Pfad bis zu einem Blatt, bevor er zurückkehrt (Backtracking).",
        "Der Algorithmus wählt immer zufällig den nächsten Knoten aus.",
        "Der Algorithmus berechnet zuerst die kürzesten Wege zur Wurzel.",
        "Der Algorithmus besucht Knoten strikt nach alphabetischer Sortierung der Namen."
      ],
      "answer": 1,
      "explanation": "Charakteristisch für die Tiefensuche (DFS) ist das tiefe Eintauchen in einen Pfad bis zu einer Sackgasse (z.B. einem Blatt), gefolgt von einem Rückschritt (Backtracking), um alternative Zweige zu erkunden.",
      "weight": 1,
      "topic": "Traversierung",
      "konzept": "DFS-Prinzip",
      "cognitive_level": "Verständnis",
      "mini_glossary": {
        "DFS (Tiefensuche)": "Traversierung, die Pfaden in die Tiefe folgt.",
        "Backtracking": "Das Zurückkehren zum letzten Verzweigungspunkt.",
        "Sackgasse": "Ein Knoten ohne unbesuchte Nachbarn (im Kontext der Suche)."
      }
    },
    {
      "question": "10. Welche Eigenschaft definiert einen Binären Suchbaum (BST)?",
      "options": [
        "Jeder Knoten hat beliebig viele Kinder, die unsortiert sind.",
        "Knoten im linken Teilbaum sind kleiner, Knoten im rechten Teilbaum sind größer als der Elternknoten.",
        "Die Wurzel ist immer das kleinste Element des gesamten Baumes.",
        "Blätter sind rot oder schwarz gefärbt.",
        "Der Baum ist immer so flach wie möglich (vollständig balanciert)."
      ],
      "answer": 1,
      "explanation": "Die definierende Eigenschaft eines BST ist die Ordnung: Für jeden Knoten $K$ gilt, dass alle Werte im linken Teilbaum kleiner als $K$ und alle Werte im rechten Teilbaum größer als $K$ sind.",
      "weight": 1,
      "topic": "Binäre Suchbäume",
      "konzept": "BST-Eigenschaft",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "BST": "Binärer Suchbaum.",
        "Teilbaum": "Der gesamte Baum, der unterhalb eines Kindknotens hängt.",
        "Ordnung": "Systematische Sortierung der Elemente."
      }
    },
    {
      "question": "11. Was ist der Hauptvorteil eines balancierten Binären Suchbaums gegenüber einer unsortierten Liste bei der Suche?",
      "options": [
        "Die Suche benötigt konstante Zeit $O(1)$.",
        "Die Suche benötigt durchschnittlich logarithmische Zeit $O(\\log n)$.",
        "Es wird kein Speicherplatz benötigt.",
        "Er kann keine doppelten Werte enthalten.",
        "Das Einfügen ist langsamer, aber das Löschen schneller."
      ],
      "answer": 1,
      "explanation": "Durch die Baumstruktur und die Sortierung kann in jedem Schritt die Hälfte der verbleibenden Daten ausgeschlossen werden. Dies führt zu einer logarithmischen Laufzeit $O(\\log n)$, was bei vielen Daten viel schneller ist als die lineare Suche $O(n)$.",
      "weight": 1,
      "topic": "Binäre Suchbäume",
      "konzept": "Laufzeitvorteil",
      "cognitive_level": "Verständnis",
      "mini_glossary": {
        "O(log n)": "Logarithmische Komplexität; wächst sehr langsam bei steigender Datenmenge.",
        "O(n)": "Lineare Komplexität; wächst proportional zur Datenmenge.",
        "Balance": "Gleichmäßige Verteilung der Knotenhöhe."
      }
    },
    {
      "question": "12. Was ist eine 'Heap'-Eigenschaft bei einem Min-Heap?",
      "options": [
        "Jeder Knoten ist größer als seine Kinder.",
        "Jeder Knoten ist kleiner oder gleich seinen Kindern.",
        "Linke Kinder sind kleiner, rechte Kinder sind größer.",
        "Nur die Blätter enthalten Datenwerte.",
        "Der Baum ist eine lineare Liste."
      ],
      "answer": 1,
      "explanation": "In einem Min-Heap muss der Wert jedes Elternknotens kleiner oder gleich den Werten seiner Kinder sein. Dadurch steht das kleinste Element (Minimum) immer an der Wurzel.",
      "weight": 1,
      "topic": "Heaps",
      "konzept": "Min-Heap-Def",
      "cognitive_level": "Reproduktion",
      "mini_glossary": {
        "Min-Heap": "Baumstruktur, bei der das Minimum oben steht.",
        "Heap-Eigenschaft": "Regel für die Beziehung zwischen Eltern und Kindern im Heap.",
        "Wurzel": "Im Min-Heap das global kleinste Element."
      }
    },
    {
      "question": "13. Sie haben einen Binären Suchbaum (BST) mit der Wurzel 10. Sie wollen den Wert 5 einfügen. Welche Aussage beschreibt den ersten Schritt korrekt?",
      "options": [
        "Da 5 < 10 ist, muss der Wert im rechten Teilbaum eingefügt werden.",
        "Da 5 < 10 ist, muss der Algorithmus in den linken Teilbaum absteigen.",
        "Der Wert 5 ersetzt die Wurzel 10.",
        "Der Wert 5 wird als neues Elternteil über die 10 gesetzt.",
        "Der Algorithmus bricht ab, da 5 ungerade ist."
      ],
      "answer": 1,
      "explanation": "Gemäß der BST-Eigenschaft gehören kleinere Werte in den linken Teilbaum. Da 5 kleiner als 10 ist, bewegt sich der Einfüge-Algorithmus nach links.",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Einfüge-Logik",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Einfüge-Entscheidung im BST",
        "schritte": [
          "Vergleichen Sie den einzufügenden Wert (5) mit dem aktuellen Knoten (10).",
          "Prüfen Sie: Ist 5 kleiner als 10? Ja.",
          "Regel anwenden: Kleinere Werte gehen nach links.",
          "Folgerung: Der nächste Schritt erfolgt im linken Teilbaum."
        ]
      },
      "mini_glossary": {
        "BST-Regel": "Links kleiner, rechts größer.",
        "Einfügen": "Prozess, einen neuen Wert an der korrekten Blattposition zu platzieren.",
        "Vergleich": "Elementare Operation zwischen zwei Werten."
      }
    },
    {
      "question": "14. Gegeben ist ein leerer BST. Sie fügen nacheinander die Werte 5, 3 und 7 ein. Welche Struktur entsteht?",
      "options": [
        "Wurzel 5, linkes Kind 3, rechtes Kind 7.",
        "Wurzel 3, linkes Kind 5, rechtes Kind 7.",
        "Wurzel 7, linkes Kind 5, rechtes Kind 3.",
        "Eine lineare Kette 5 → 3 → 7.",
        "Wurzel 5, linkes Kind 7, rechtes Kind 3."
      ],
      "answer": 0,
      "explanation": "Die 5 wird Wurzel. Die 3 ist kleiner als 5 $\\rightarrow$ linkes Kind. Die 7 ist größer als 5 $\\rightarrow$ rechtes Kind. Es entsteht ein klassischer Baum mit Wurzel und zwei Kindern.",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Aufbau BST",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Schrittweiser Aufbau",
        "schritte": [
          "Schritt 1: 5 wird in den leeren Baum eingefügt $\\rightarrow$ Wurzel ist 5.",
          "Schritt 2: 3 einfügen. 3 < 5 $\\rightarrow$ 3 wird linkes Kind von 5.",
          "Schritt 3: 7 einfügen. 7 > 5 $\\rightarrow$ 7 wird rechtes Kind von 5.",
          "Ergebnis: Wurzel 5 mit Kindern 3 (links) und 7 (rechts)."
        ]
      },
      "mini_glossary": {
        "Wurzel": "Erster eingefügter Knoten.",
        "Linkes Kind": "Position für kleinere Werte.",
        "Rechtes Kind": "Position für größere Werte."
      }
    },
    {
      "question": "15. Ein Baum hat die Knoten A, B, C, D. A ist die Wurzel. B und C sind Kinder von A. D ist ein Kind von B. Welche Knoten sind Blätter?",
      "options": [
        "Nur D",
        "Nur C",
        "C und D",
        "B und C",
        "A und D"
      ],
      "answer": 2,
      "explanation": "Blätter sind Knoten ohne Kinder. C hat keine Kinder (nur A als Elternteil). D hat keine Kinder (nur B als Elternteil). B hat ein Kind (D), ist also kein Blatt. A ist Wurzel.",
      "weight": 2,
      "topic": "Terminologie",
      "konzept": "Blätter identifizieren",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Identifikation von Blättern",
        "schritte": [
          "Zeichnen Sie die Struktur gedanklich: A oben.",
          "Verzweigung von A zu B und C.",
          "Verzweigung von B zu D.",
          "Prüfen Sie jeden Knoten auf Nachfolger: C hat keine, D hat keine.",
          "Daher sind C und D die Blätter."
        ]
      },
      "mini_glossary": {
        "Blatt": "Knotengrad (ausgehend) ist 0.",
        "Struktur": "Die Anordnung der Knoten und Kanten.",
        "Nachfolger": "Kindknoten."
      }
    },
    {
      "question": "16. Welche Traversierungsreihenfolge (Pre-Order: Wurzel zuerst) ergibt sich für den Baum: Wurzel A, linkes Kind B, rechtes Kind C?",
      "options": [
        "B, A, C",
        "A, B, C",
        "B, C, A",
        "C, B, A",
        "A, C, B"
      ],
      "answer": 1,
      "explanation": "Pre-Order bedeutet: Zuerst die Wurzel (A), dann der linke Teilbaum (B), dann der rechte Teilbaum (C). Daher A, B, C.",
      "weight": 2,
      "topic": "Traversierung",
      "konzept": "Pre-Order",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Pre-Order Ablauf",
        "schritte": [
          "Regel für Pre-Order: Wurzel $\\rightarrow$ Links $\\rightarrow$ Rechts.",
          "Besuche Wurzel: A.",
          "Besuche linken Teilbaum: B.",
          "Besuche rechten Teilbaum: C.",
          "Zusammengesetzt: A, B, C."
        ]
      },
      "mini_glossary": {
        "Pre-Order": "Wurzel zuerst traversieren.",
        "In-Order": "Wurzel in der Mitte traversieren.",
        "Post-Order": "Wurzel zuletzt traversieren."
      }
    },
    {
      "question": "17. Sie suchen in einem ungewichteten Graphen (Baum) den kürzesten Weg von der Wurzel zu einem Zielknoten. Welcher Algorithmus garantiert, diesen Weg mit den wenigsten Kanten zuerst zu finden?",
      "options": [
        "Tiefensuche (DFS)",
        "Breitensuche (BFS)",
        "Zufallssuche",
        "Sortieren der Knotenwerte",
        "Löschen des Baumes"
      ],
      "answer": 1,
      "explanation": "Die Breitensuche (BFS) durchsucht den Baum schichtweise. Sie findet Knoten mit Distanz 1 zuerst, dann Distanz 2 usw. Daher findet sie den kürzesten Weg (in Kantenanzahl) garantiert als erstes.",
      "weight": 2,
      "topic": "Traversierung",
      "konzept": "BFS-Anwendung",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Warum BFS kürzeste Wege findet",
        "schritte": [
          "BFS breitet sich kreisförmig (ebenenweise) um den Startknoten aus.",
          "Ebene $k$ wird erst vollständig geprüft, bevor Ebene $k+1$ betreten wird.",
          "Sobald das Ziel gefunden wird, ist garantiert, dass kein Pfad mit weniger Kanten existiert (da frühere Ebenen bereits leer geprüft wurden).",
          "DFS hingegen könnte sich in einem sehr langen Pfad verlieren, bevor es das nahe Ziel findet."
        ]
      },
      "mini_glossary": {
        "Kürzester Weg": "Pfad mit der minimalen Anzahl an Kanten.",
        "Ungewichtet": "Alle Kanten zählen gleich viel (Länge 1).",
        "Schichtweise": "Ebene für Ebene."
      }
    },
    {
      "question": "18. Ein binärer Baum hat die Höhe 3. Was ist die maximal mögliche Anzahl an Knoten in diesem Baum (Wurzel auf Tiefe 0)?",
      "options": [
        "7 Knoten",
        "8 Knoten",
        "15 Knoten",
        "10 Knoten",
        "3 Knoten"
      ],
      "answer": 2,
      "explanation": "Ein voller binärer Baum der Höhe $h$ hat $2^{h+1} - 1$ Knoten. Bei Höhe 3 (Ebenen 0, 1, 2, 3) sind das $2^4 - 1 = 16 - 1 = 15$ Knoten.",
      "weight": 2,
      "topic": "Terminologie",
      "konzept": "Maximal-Knoten",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Berechnung maximaler Knoten",
        "schritte": [
          "Ebene 0: 1 Knoten ($2^0$).",
          "Ebene 1: 2 Knoten ($2^1$).",
          "Ebene 2: 4 Knoten ($2^2$).",
          "Ebene 3: 8 Knoten ($2^3$).",
          "Summe: $1 + 2 + 4 + 8 = 15$. Alternativ Formel $2^{h+1}-1$ nutzen."
        ]
      },
      "mini_glossary": {
        "Vollständiger Baum": "Alle Ebenen sind voll besetzt.",
        "Höhe h": "Maximale Tiefe (hier 3).",
        "Exponentielles Wachstum": "Die Knotenanzahl verdoppelt sich pro Ebene."
      }
    },
    {
      "question": "19. In welchem Szenario degeneriert ein Binärer Suchbaum (BST) zu einer verketteten Liste (Linie)?",
      "options": [
        "Wenn die Daten zufällig eingefügt werden.",
        "Wenn die Daten bereits sortiert (auf- oder absteigend) eingefügt werden.",
        "Wenn immer abwechselnd kleine und große Werte eingefügt werden.",
        "Wenn negative Zahlen eingefügt werden.",
        "Wenn der Baum als Max-Heap organisiert ist."
      ],
      "answer": 1,
      "explanation": "Werden Daten sortiert eingefügt (z.B. 1, 2, 3, 4), landet jedes Element immer rechts vom Vorgänger. Es entstehen keine linken Verzweigungen, der Baum wird zur Linie.",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Entartung",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Entartung des BST",
        "schritte": [
          "Nehmen Sie die Folge 1, 2, 3.",
          "1 ist Wurzel.",
          "2 > 1 $\\rightarrow$ rechts von 1.",
          "3 > 2 $\\rightarrow$ rechts von 2.",
          "Struktur: $1 \\to 2 \\to 3$. Dies ist geometrisch eine Linie, keine Baumkrone."
        ]
      },
      "mini_glossary": {
        "Entartung": "Verlust der effizienten Baumstruktur.",
        "Verkettete Liste": "Datenstruktur, bei der jedes Element nur einen Nachfolger hat.",
        "Worst Case": "Der ungünstigste Fall für einen Algorithmus."
      }
    },
    {
      "question": "20. Welche Traversierungsart liefert bei einem Binären Suchbaum (BST) die Werte in aufsteigend sortierter Reihenfolge?",
      "options": [
        "Pre-Order (Wurzel-Links-Rechts)",
        "Post-Order (Links-Rechts-Wurzel)",
        "In-Order (Links-Wurzel-Rechts)",
        "Level-Order (Breitensuche)",
        "Reverse-Order"
      ],
      "answer": 2,
      "explanation": "Beim In-Order-Durchlauf wird erst der gesamte linke Teilbaum (kleinere Werte) besucht, dann die Wurzel (Mittelwert), dann der rechte Teilbaum (größere Werte). Dies entspricht der Sortierreihenfolge.",
      "weight": 2,
      "topic": "Traversierung",
      "konzept": "In-Order Sortierung",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "In-Order und Sortierung",
        "schritte": [
          "Struktur BST: Links < Wurzel < Rechts.",
          "In-Order besucht: 1. Links, 2. Wurzel, 3. Rechts.",
          "Logik: Besuche erst alles was kleiner ist, dann den Wert selbst, dann alles was größer ist.",
          "Das Ergebnis ist mathematisch zwingend eine aufsteigende Folge."
        ]
      },
      "mini_glossary": {
        "In-Order": "Traversierungsstrategie für Sortierung.",
        "Aufsteigend": "Von klein nach groß.",
        "Teilbaum": "Rekursive Unterstruktur."
      }
    },
    {
      "question": "21. Ein Max-Heap enthält die Werte 10, 20, 5. Welche Zahl muss an der Wurzel stehen?",
      "options": [
        "5",
        "10",
        "20",
        "Beliebig",
        "Die Zahl, die als erstes eingefügt wurde."
      ],
      "answer": 2,
      "explanation": "In einem Max-Heap gilt für jeden Knoten: Elternwert $\\ge$ Kindwert. Das bedeutet, das größte Element des gesamten Baumes muss zwingend an der Wurzel stehen.",
      "weight": 2,
      "topic": "Heaps",
      "konzept": "Max-Heap-Wurzel",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Eigenschaft des Max-Heap",
        "schritte": [
          "Def: Elternknoten $\\ge$ alle Kinder.",
          "Dies gilt transitiv bis zur Wurzel.",
          "Daher muss die Wurzel größer oder gleich allen anderen Knoten im Baum sein.",
          "Das Maximum von {10, 20, 5} ist 20. Also steht 20 an der Wurzel."
        ]
      },
      "mini_glossary": {
        "Max-Heap": "Heap, der das Maximum schnell zugreifbar macht.",
        "Wurzel": "Oberstes Element.",
        "Maximum": "Größter Wert einer Menge."
      }
    },
    {
      "question": "22. Welche Aussage über die Anzahl der Pfade zwischen zwei beliebigen Knoten $A$ und $B$ in einem Baum ist korrekt?",
      "options": [
        "Es gibt gar keinen Pfad.",
        "Es gibt genau einen eindeutigen Pfad.",
        "Es gibt mindestens zwei Pfade.",
        "Die Anzahl hängt von der Tiefe des Baumes ab.",
        "Es gibt unendlich viele Pfade, wenn man Kanten doppelt nutzen darf."
      ],
      "answer": 1,
      "explanation": "Die Zyklenfreiheit und der Zusammenhang eines Baumes garantieren mathematisch, dass es zwischen jedem Paar von Knoten exakt einen einzigen, einfachen Pfad gibt.",
      "weight": 2,
      "topic": "Definition & Eigenschaften",
      "konzept": "Eindeutiger Pfad",
      "cognitive_level": "Verständnis",
      "extended_explanation": {
        "titel": "Eindeutigkeit von Pfaden",
        "schritte": [
          "Wäre gar kein Pfad vorhanden, wäre der Graph nicht zusammenhängend.",
          "Gäbe es zwei verschiedene Pfade, würden diese zusammen einen Kreis (Zyklus) bilden.",
          "Da ein Baum per Definition zyklenfrei und zusammenhängend ist, bleibt nur genau ein Pfad übrig.",
          "Dies erleichtert die Navigation in Hierarchien erheblich."
        ]
      },
      "mini_glossary": {
        "Pfad": "Verbindungsweg zwischen Knoten.",
        "Eindeutig": "Genau eine Möglichkeit.",
        "Zyklenfrei": "Keine geschlossenen Kreise."
      }
    },
    {
      "question": "23. Sie implementieren eine Verzeichnisstruktur eines Dateisystems (Ordner und Dateien). Welche Baumstruktur eignet sich am besten als mentales Modell?",
      "options": [
        "Ein binärer Suchbaum, sortiert nach Dateigröße.",
        "Ein allgemeiner gewurzelter Baum (N-ary Tree).",
        "Ein ungerichteter Kreisgraph.",
        "Ein Wald aus isolierten Knoten.",
        "Ein Max-Heap."
      ],
      "answer": 1,
      "explanation": "Ein Dateisystem ist hierarchisch: Ein Ordner kann beliebig viele Unterordner oder Dateien enthalten (nicht nur maximal zwei). Daher ist ein allgemeiner gewurzelter Baum das passende Modell.",
      "weight": 2,
      "topic": "Anwendungen",
      "konzept": "Modellierung",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Dateisystem als Baum",
        "schritte": [
          "Wurzel = Laufwerk oder Root-Verzeichnis (/).",
          "Innere Knoten = Verzeichnisse/Ordner.",
          "Blätter = Dateien oder leere Ordner.",
          "Da ein Ordner 0 bis $n$ Elemente enthalten kann, ist die Beschränkung auf binäre Bäume (max 2 Kinder) hier nicht sinnvoll."
        ]
      },
      "mini_glossary": {
        "N-ary Tree": "Baum, bei dem Knoten beliebig viele Kinder haben können.",
        "Dateisystem": "Organisationsstruktur für Daten auf Speichermedien.",
        "Modell": "Abstrakte Darstellung der Realität."
      }
    },
    {
      "question": "24. Was passiert, wenn Sie in einem Baum eine beliebige Kante entfernen?",
      "options": [
        "Der Graph bleibt unverändert.",
        "Es entsteht ein Zyklus.",
        "Der Baum zerfällt in zwei unverbundene Komponenten (der Graph ist nicht mehr zusammenhängend).",
        "Die Anzahl der Knoten verringert sich.",
        "Der Baum wird automatisch zu einem Wald mit 3 Bäumen."
      ],
      "answer": 2,
      "explanation": "Da ein Baum minimale Konnektivität besitzt ($n-1$ Kanten), ist jede Kante eine 'Brücke'. Das Entfernen einer Kante unterbricht den einzigen Pfad zwischen bestimmten Knotenpaaren, wodurch der Graph zerfällt.",
      "weight": 2,
      "topic": "Definition & Eigenschaften",
      "konzept": "Brückeneigenschaft",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Kanten als Brücken",
        "schritte": [
          "Ein Baum hat keine redundanten Verbindungen (keine Kreise).",
          "Jede Kante ist die einzige Verbindung zwischen den zwei Teilbäumen, die sie verbindet.",
          "Fällt diese Verbindung weg, gibt es keinen Umweg.",
          "Der Graph zerfällt somit in zwei Teile."
        ]
      },
      "mini_glossary": {
        "Brücke": "Eine Kante, deren Entfernung die Zusammenhangskomponenten erhöht.",
        "Redundanz": "Vorhandensein mehrerer Wege (fehlt im Baum).",
        "Komponente": "Zusammenhängender Teilgraph."
      }
    },
    {
      "question": "25. Welche Aussage trifft auf einen Spannbaum (Spanning Tree) eines Graphen zu?",
      "options": [
        "Er enthält alle Knoten des Ursprungsgraphen, aber nur eine Teilmenge der Kanten, sodass keine Zyklen entstehen.",
        "Er enthält alle Kanten des Ursprungsgraphen.",
        "Er enthält nur die Knoten, die einen hohen Grad haben.",
        "Er fügt neue Knoten hinzu, um den Graphen zu verbinden.",
        "Er ist immer identisch mit dem Ursprungsgraphen."
      ],
      "answer": 0,
      "explanation": "Ein Spannbaum verbindet alle Knoten eines Graphen mit der minimal nötigen Anzahl an Kanten. Er 'spannt' den Graphen auf, indem er Kreise entfernt, aber den Zusammenhang wahrt.",
      "weight": 2,
      "topic": "Anwendungen",
      "konzept": "Spanning Tree",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Prinzip des Spannbaums",
        "schritte": [
          "Start: Ein beliebiger zusammenhängender Graph (evt. mit Zyklen).",
          "Ziel: Ein Baum, der alle Knoten erreicht.",
          "Vorgehen: Überflüssige Kanten (die Zyklen schließen) werden entfernt.",
          "Ergebnis: Ein Gerüst (Skelett) des Graphen."
        ]
      },
      "mini_glossary": {
        "Spannbaum": "Teilgraph, der ein Baum ist und alle Knoten enthält.",
        "Teilmenge": "Eine Auswahl aus der Gesamtmenge.",
        "Gerüst": "Tragende Struktur."
      }
    },
    {
      "question": "26. Sie möchten in einem binären Suchbaum den kleinsten Wert finden. Welcher Strategie folgen Sie?",
      "options": [
        "Ich gehe von der Wurzel immer nach rechts.",
        "Ich gehe von der Wurzel immer nach links, bis ich ein Blatt oder einen Knoten ohne linken Nachfolger erreiche.",
        "Ich muss den ganzen Baum mit BFS durchsuchen.",
        "Ich wähle zufällig einen Pfad.",
        "Ich prüfe nur die Blätter der rechten Seite."
      ],
      "answer": 1,
      "explanation": "Aufgrund der BST-Eigenschaft (kleinere Werte links) befindet sich das Minimum ganz 'links außen'. Man folgt also iterativ den linken Kindzeigern, bis es nicht mehr weitergeht.",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Minimum finden",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Suche des Minimums",
        "schritte": [
          "Start an der Wurzel.",
          "Gibt es ein linkes Kind? Wenn ja, gehe dorthin (der Wert ist kleiner).",
          "Wiederhole dies solange, bis kein linkes Kind mehr existiert.",
          "Der aktuelle Knoten ist das Minimum."
        ]
      },
      "mini_glossary": {
        "Minimum": "Der kleinste Wert im Datensatz.",
        "Iterativ": "Schrittweises Wiederholen.",
        "Links-Abstieg": "Strategie, um zu kleineren Werten zu gelangen."
      }
    },
    {
      "question": "27. Warum sind AVL-Bäume oder Rot-Schwarz-Bäume in der Praxis oft nützlicher als einfache Binäre Suchbäume?",
      "options": [
        "Sie speichern Daten komprimiert.",
        "Sie balancieren sich selbst, um im Worst-Case eine Laufzeit von $O(\\log n)$ zu garantieren.",
        "Sie können mehr als zwei Kinder pro Knoten haben.",
        "Sie benötigen keine Vergleichsoperationen.",
        "Sie sind einfacher zu implementieren."
      ],
      "answer": 1,
      "explanation": "Einfache BSTs können zur Linie entarten ($O(n)$). Selbstbalancierende Bäume wie AVL führen Rotationen durch, um die Höhe gering zu halten, was die Sucheffizienz von $O(\\log n)$ sichert.",
      "weight": 2,
      "topic": "Erweiterte Bäume",
      "konzept": "Selbstbalancierung",
      "cognitive_level": "Verständnis",
      "extended_explanation": {
        "titel": "Notwendigkeit der Balance",
        "schritte": [
          "Problem: Ein schiefer Baum ist langsam (wie eine Liste).",
          "Lösung: Algorithmen (wie AVL), die nach jedem Einfügen die Form prüfen.",
          "Aktion: Wird der Baum zu schief, wird er 'rotiert' (umstrukturiert).",
          "Nutzen: Die Tiefe bleibt minimal, die Geschwindigkeit maximal."
        ]
      },
      "mini_glossary": {
        "AVL-Baum": "Einer der ältesten selbstbalancierenden Suchbäume.",
        "Rotation": "Lokale Umstrukturierung der Knotenzeiger.",
        "Garantie": "Sichere Eigenschaft unabhängig von der Eingabe."
      }
    },
    {
      "question": "28. Ein Knoten $A$ hat die Kinder $B$ und $C$. In einer Adjazenzliste für diesen gerichteten Baum (Richtung Eltern $\\to$ Kind), wie sieht der Eintrag für $A$ aus?",
      "options": [
        "$A: []$ (leere Liste)",
        "$A: [B, C]$",
        "$B: [A], C: [A]$",
        "$A: [Wurzel]$",
        "$A: [A]$"
      ],
      "answer": 1,
      "explanation": "In einer Adjazenzliste werden zu jedem Knoten dessen Nachbarn (hier: Kinder) gespeichert. Da die Richtung Eltern $\\to$ Kind ist, enthält die Liste von $A$ die Elemente $B$ und $C$.",
      "weight": 2,
      "topic": "Traversierung",
      "konzept": "Repräsentation",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Speicherung als Adjazenzliste",
        "schritte": [
          "Adjazenzliste = 'Wer ist mein Nachbar/Nachfolger?'.",
          "Knoten A ist der Ursprung.",
          "Kanten gehen zu B und C.",
          "Also speichert A die Liste seiner Ziele: [B, C]."
        ]
      },
      "mini_glossary": {
        "Adjazenzliste": "Standardform zur Speicherung von Graphen im Computer.",
        "Gerichtet": "Verbindung hat eine Pfeilrichtung.",
        "Nachbar": "Direkt verbundener Knoten."
      }
    },
    {
      "question": "29. Was unterscheidet einen Baum von einem allgemeinen Graphen wesentlich?",
      "options": [
        "Ein Baum hat Kanten, ein Graph nicht.",
        "Ein Baum darf Zyklen haben, ein Graph nicht.",
        "Ein Baum ist zyklenfrei und zusammenhängend, ein Graph muss das nicht sein.",
        "Ein Baum hat immer weniger als 5 Knoten.",
        "Es gibt keinen Unterschied, die Begriffe sind synonym."
      ],
      "answer": 2,
      "explanation": "Der Graph ist der Überbegriff. Der Baum ist ein *spezieller* Graph mit strikten Einschränkungen: Er darf keine Kreise enthalten und muss zusammenhängend sein.",
      "weight": 2,
      "topic": "Definition & Eigenschaften",
      "konzept": "Vergleich Graph-Baum",
      "cognitive_level": "Verständnis",
      "extended_explanation": {
        "titel": "Spezialisierung Baum",
        "schritte": [
          "Graph = Menge von Knoten und Kanten (sehr allgemein).",
          "Darf Zyklen haben? Graph: Ja. Baum: Nein.",
          "Muss zusammenhängend sein? Graph: Nein. Baum: Ja.",
          "Fazit: Jeder Baum ist ein Graph, aber nicht jeder Graph ist ein Baum."
        ]
      },
      "mini_glossary": {
        "Spezialisierung": "Einschränkung der Definition auf eine Untermenge.",
        "Allgemeiner Graph": "Kann Zyklen haben, unverbunden sein, etc.",
        "Einschränkung": "Regel, die erfüllt sein muss."
      }
    },
    {
      "question": "30. Sie wollen alle Dateien in einem Verzeichnisbaum löschen. Warum ist hier die Post-Order-Traversierung (Kinder zuerst, dann Wurzel) sinnvoll?",
      "options": [
        "Weil man zuerst den Ordner löschen muss, bevor man den Inhalt löschen kann.",
        "Weil man sicherstellen muss, dass ein Ordner leer ist (Kinder gelöscht), bevor man den Ordner selbst entfernt.",
        "Weil Post-Order schneller ist als Pre-Order.",
        "Weil man alphabetisch vorgehen muss.",
        "Weil man sonst die Wurzel nicht findet."
      ],
      "answer": 1,
      "explanation": "Post-Order besucht und verarbeitet die Kinder *vor* dem Elternknoten. Beim Löschen ist das ideal: Erst den Inhalt (Kinder) leeren, dann den nun leeren Ordner (Eltern) entfernen.",
      "weight": 2,
      "topic": "Anwendungen",
      "konzept": "Lösch-Reihenfolge",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Lösch-Strategie",
        "schritte": [
          "Versuch: Lösche Ordner zuerst (Pre-Order). Fehler: 'Ordner nicht leer'.",
          "Lösung: Gehe nach unten bis zu den Dateien (Blätter).",
          "Aktion: Lösche Dateien.",
          "Rückweg: Jetzt ist der Ordner leer und kann gelöscht werden (Post-Order)."
        ]
      },
      "mini_glossary": {
        "Post-Order": "Verarbeitung von unten nach oben.",
        "Abhängigkeit": "Der Elternknoten benötigt den Abschluss der Kinder.",
        "Ressourcenfreigabe": "Systematisches Aufräumen von Speicher."
      }
    },
    {
      "question": "31. Gegeben ist ein Binärer Suchbaum (BST) mit Wurzel 50, linkem Kind 30 und rechtem Kind 70. Was passiert im Worst-Case (schlechtester Fall) für die Suche, wenn wir stattdessen einen unbalancierten Baum mit den Werten 10, 20, 30, 40, 50 (in dieser Reihenfolge eingefügt) betrachten?",
      "options": [
        "Die Suche bleibt bei $O(\\log n)$.",
        "Die Suche wird zu $O(1)$ beschleunigt.",
        "Die Suche verschlechtert sich zu $O(n)$, da der Baum zur Linie wird.",
        "Der Baum sortiert sich automatisch neu.",
        "Die Suche ist nicht mehr möglich."
      ],
      "answer": 2,
      "explanation": "Wenn Daten sortiert in einen einfachen BST eingefügt werden, entsteht eine 'rechte Kette'. Um das Element 50 zu finden, müssen alle vorherigen Knoten (10, 20, 30, 40) passiert werden. Die Laufzeit ist linear ($O(n)$).",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Laufzeitvergleich",
      "cognitive_level": "Anwendung",
      "extended_explanation": {
        "titel": "Analyse der linearen Entartung",
        "schritte": [
          "Struktur 1 (Balanciert): 50 oben, 30 links, 70 rechts. Tiefe = 1.",
          "Struktur 2 (Kette): $10 \\to 20 \\to 30 \\to 40 \\to 50$. Tiefe = 4.",
          "Folge: Im balancierten Baum braucht man wenige Vergleiche.",
          "In der Kette muss man *jeden* Knoten besuchen $\\rightarrow O(n)$."
        ]
      },
      "mini_glossary": {
        "Worst-Case": "Das Szenario mit der maximalen Laufzeit.",
        "Lineare Laufzeit": "Zeit wächst 1:1 mit Datenmenge.",
        "Tiefe": "Maßgeblich für die Suchgeschwindigkeit."
      }
    },
    {
      "question": "32. Welche Aussage beschreibt die Komplexität der Suche in einem ideal balancierten binären Suchbaum mit $n$ Knoten korrekt?",
      "options": [
        "Die Anzahl der Schritte wächst quadratisch ($n^2$).",
        "Die Anzahl der Schritte entspricht der Höhe des Baumes, also etwa $\\log_2 n$.",
        "Die Anzahl der Schritte ist unabhängig von $n$.",
        "Man muss immer alle $n$ Knoten besuchen.",
        "Die Schritte halbieren sich mit jedem Knoten, also $n/2$."
      ],
      "answer": 1,
      "explanation": "In einem balancierten Baum halbiert jeder Vergleichsschritt (links/rechts) den Suchraum. Bei $n$ Elementen kann man dies $\\log_2 n$ mal tun, bis man bei einem Blatt ankommt.",
      "weight": 2,
      "topic": "Binäre Suchbäume",
      "konzept": "Logarithmische Suche",
      "cognitive_level": "Verständnis",
      "extended_explanation": {
        "titel": "Das Prinzip 'Teile und Herrsche'",
        "schritte": [
          "Stellen Sie sich 1000 Elemente vor.",
          "1. Vergleich: Gehe links. 500 Elemente übrig.",
          "2. Vergleich: Gehe rechts. 250 Elemente übrig.",
          "Nach ca. 10 Schritten ($2^{10} \\approx 1000$) ist man am Ziel.",
          "Das ist die logarithmische Effizienz."
        ]
      },
      "mini_glossary": {
        "Logarithmus Dualis": "Logarithmus zur Basis 2.",
        "Suchraum": "Menge der noch möglichen Kandidaten.",
        "Effizienz": "Verhältnis von Aufwand zu Nutzen."
      }
    },
    {
      "question": "33. Sie vergleichen BFS (Breitensuche) und DFS (Tiefensuche) hinsichtlich des Speicherverbrauchs. Welches Problem kann bei BFS in sehr breiten Bäumen auftreten?",
      "options": [
        "BFS verbraucht kaum Speicher.",
        "BFS muss alle Knoten der aktuellen Ebene in der Queue speichern, was bei breiten Bäumen speicherintensiv ist.",
        "BFS bricht bei breiten Bäumen immer ab.",
        "DFS verbraucht immer mehr Speicher als BFS.",
        "Es gibt keinen Unterschied im Speicherverbrauch."
      ],
      "answer": 1,
      "explanation": "BFS speichert alle Nachbarn der aktuellen Ebene in der Warteschlange. Wenn ein Baum sehr stark verzweigt ist (viele Kinder pro Knoten), wächst diese Warteschlange enorm an, was den Arbeitsspeicher belasten kann.",
      "weight": 3,
      "topic": "Traversierung",
      "konzept": "Speicherkomplexität",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Speicherbedarf BFS vs. DFS",
        "schritte": [
          "DFS speichert nur den aktuellen Pfad von der Wurzel (proportional zur Tiefe/Höhe).",
          "BFS speichert die komplette Frontlinie der Suche (Breite der Ebene).",
          "In einem Baum wächst die Breite oft exponentiell ($1, 2, 4, 8, ...$).",
          "Daher kann BFS bei großen Bäumen den Speicher sprengen."
        ]
      },
      "mini_glossary": {
        "Speicherkomplexität": "Wie viel RAM ein Algorithmus benötigt.",
        "Breite": "Maximale Anzahl Knoten auf einer Ebene.",
        "Frontlinie": "Die Menge der aktuell entdeckten, aber noch nicht bearbeiteten Knoten."
      }
    },
    {
      "question": "34. Warum ist die Pfadlänge zwischen zwei Knoten in einem Baum eindeutig bestimmt, in einem allgemeinen Graphen mit Zyklen jedoch nicht?",
      "options": [
        "In Graphen sind Kanten länger.",
        "In einem Zyklus kann man 'im Kreis laufen' und so den Pfad beliebig verlängern oder alternative Routen nehmen.",
        "Bäume haben weniger Knoten als Graphen.",
        "In Bäumen gibt es keine Richtung.",
        "Der Algorithmus verbietet Umwege in Graphen."
      ],
      "answer": 1,
      "explanation": "Sobald ein Zyklus existiert, gibt es mindestens zwei Wege um den Kreis herum (linksrum/rechtsrum) oder man kann den Kreis mehrfach durchlaufen. Da Bäume zyklenfrei sind, entfällt diese Option; der Weg ist fixiert.",
      "weight": 3,
      "topic": "Definition & Eigenschaften",
      "konzept": "Topologische Eindeutigkeit",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Einfluss von Zyklen auf Wege",
        "schritte": [
          "Denken Sie an einen Kreisverkehr (Zyklus).",
          "Sie können direkt zur Ausfahrt fahren (Weg A).",
          "Oder Sie fahren eine Ehrenrunde und dann raus (Weg B).",
          "Ohne Kreise (Baum) ist die Straße eine Sackgasse oder Einbahnstraße ohne Alternative: Es gibt nur *einen* Weg."
        ]
      },
      "mini_glossary": {
        "Zyklus": "Strukturelle Redundanz im Graphen.",
        "Eindeutigkeit": "Mathematische Eigenschaft: Lösung ist singulär.",
        "Topologie": "Lehre von der Lage und Anordnung geometrischer Gebilde."
      }
    },
    {
      "question": "35. Ein Algorithmus soll prüfen, ob ein gegebener Graph ein Baum ist. Welche Strategie ist korrekt und effizient?",
      "options": [
        "Prüfe, ob alle Knoten grün sind.",
        "Prüfe: 1. Ist er zusammenhängend? 2. Gilt $Anzahl\\_Kanten = Anzahl\\_Knoten - 1$?",
        "Lösche alle Kanten und zähle die Knoten.",
        "Führe Kanten ein, bis er vollvermascht ist.",
        "Multipliziere die Knotenanzahl mit der Kantenanzahl."
      ],
      "answer": 1,
      "explanation": "Die Kombination aus 'zusammenhängend' (alle Knoten erreichbar) und der korrekten Kantenanzahl ($n-1$) ist eine hinreichende Bedingung für einen Baum. Alternativ: zusammenhängend und zyklenfrei.",
      "weight": 3,
      "topic": "Definition & Eigenschaften",
      "konzept": "Baum-Verifikation",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Validierung eines Baumes",
        "schritte": [
          "Schritt 1: Starte BFS/DFS an einem Knoten. Werden alle $n$ Knoten erreicht? $\\rightarrow$ Zusammenhängend.",
          "Schritt 2: Zähle Kanten $e$.",
          "Schritt 3: Prüfe Formel $e = n - 1$.",
          "Wenn beides stimmt, ist es mathematisch sicher ein Baum."
        ]
      },
      "mini_glossary": {
        "Verifikation": "Nachweis der Korrektheit.",
        "Hinreichende Bedingung": "Erfüllung garantiert die Eigenschaft.",
        "Effizienz": "Erreichen des Ziels mit minimalem Rechenaufwand."
      }
    },
    {
      "question": "36. Bei der Entscheidung zwischen einer Hash-Tabelle und einem Binären Suchbaum (BST): Welches Argument spricht für den BST?",
      "options": [
        "Der BST hat immer $O(1)$ Zugriffszeit.",
        "Der BST ermöglicht Bereichsabfragen (z.B. 'alle Werte zwischen 10 und 20') effizient, da die Daten sortiert sind.",
        "Der BST verbraucht weniger Speicher für die Datenwerte.",
        "Der BST braucht keine Zeiger.",
        "Es gibt kein Argument für den BST, Hash-Tabellen sind immer besser."
      ],
      "answer": 1,
      "explanation": "Hash-Tabellen speichern Daten unsortiert (gestreut). Ein BST speichert Daten strukturell sortiert. Daher sind Abfragen nach Bereichen (Range Queries) oder das Finden des Nächstgrößeren im BST viel einfacher.",
      "weight": 3,
      "topic": "Anwendungen",
      "konzept": "Vergleich BST vs. Hash",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Datenstruktur-Auswahl",
        "schritte": [
          "Hash-Tabelle: Super schnell für *einzelne* Treffer ($O(1)$), aber chaotische Ordnung.",
          "BST: Schnell ($O(\\log n)$), aber erhält die *Ordnung*.",
          "Szenario: 'Gib mir alle Kunden mit Namen A... bis C...'.",
          "Lösung: Im BST ein Teilbaum-Traversal. In Hash-Tabelle unmöglich (muss alles prüfen)."
        ]
      },
      "mini_glossary": {
        "Bereichsabfrage (Range Query)": "Suche nach Werten in einem Intervall.",
        "Hash-Tabelle": "Datenstruktur für schnellen Schlüssel-Wert-Zugriff.",
        "Ordnungserhaltung": "Struktur spiegelt Sortierung wider."
      }
    },
    {
      "question": "37. Sie sollen einen 'Spanning Tree Algorithm' (z.B. Kruskal oder Prim) erklären. Was ist das Ziel dieser Algorithmen in einem gewichteten Graphen?",
      "options": [
        "Die Kanten mit den höchsten Gewichten zu finden.",
        "Einen Baum zu finden, der alle Knoten verbindet und dessen Summe der Kantengewichte minimal ist (MST).",
        "Den Graphen in zwei Hälften zu teilen.",
        "Den längsten Pfad zwischen zwei Knoten zu finden.",
        "Alle Knoten zu löschen."
      ],
      "answer": 1,
      "explanation": "Das Ziel ist der 'Minimum Spanning Tree' (MST). Man möchte ein Netzwerk schaffen, das alle Punkte verbindet (z.B. Stromleitungen zu Häusern), aber die Baukosten (Summe der Gewichte) minimiert.",
      "weight": 3,
      "topic": "Anwendungen",
      "konzept": "Minimaler Spannbaum",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Idee des MST",
        "schritte": [
          "Problem: Verbinde $n$ Städte mit Kabeln.",
          "Bedingung: Jede Stadt muss am Netz sein (Zusammenhang).",
          "Optimierung: Kabel sind teuer $\\rightarrow$ Gesamtlänge minimieren.",
          "Lösung: Ein Baum (keine unnötigen Kreise) mit den billigsten möglichen Kanten."
        ]
      },
      "mini_glossary": {
        "MST": "Minimum Spanning Tree.",
        "Gewichteter Graph": "Kanten haben Kosten/Längen.",
        "Optimierung": "Suche nach der besten Lösung."
      }
    },
    {
      "question": "38. Warum ist die Rekursion eine so natürliche Methode zur Implementierung von Baum-Algorithmen?",
      "options": [
        "Weil Computer Rekursion schneller ausführen als Schleifen.",
        "Weil Bäume selbst rekursiv definiert sind (Ein Baum besteht aus Wurzel + Teilbäumen).",
        "Weil Rekursion weniger Speicher braucht.",
        "Weil man bei der Rekursion keine Variablen braucht.",
        "Es ist Zufall, Iteration wäre immer einfacher."
      ],
      "answer": 1,
      "explanation": "Die Datenstruktur ist selbstähnlich: Ein Kindknoten ist wiederum Wurzel eines eigenen Teilbaums. Diese rekursive Struktur spiegelt sich direkt in rekursiven Funktionen wider (z.B. `visit(node) → visit(node.left)`).",
      "weight": 3,
      "topic": "Traversierung",
      "konzept": "Rekursion & Selbstähnlichkeit",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Selbstähnlichkeit von Bäumen",
        "schritte": [
          "Betrachte den linken Ast eines Baumes.",
          "Er sieht strukturell exakt so aus wie der ganze Baum (Wurzel, Kinder).",
          "Algorithmus-Idee: 'Löse das Problem für den aktuellen Knoten, dann rufe dich selbst für die Kinder auf'.",
          "Das passt perfekt zusammen."
        ]
      },
      "mini_glossary": {
        "Rekursion": "Funktion, die sich selbst aufruft.",
        "Selbstähnlichkeit": "Teile des Ganzen sehen aus wie das Ganze.",
        "Induktion": "Logisches Schließen vom Einzelnen aufs Ganze."
      }
    },
    {
      "question": "39. Ein Ausdrucksbaum (Expression Tree) speichert die Formel `(3 + 4) * 5`. Wo steht der Operator `*`?",
      "options": [
        "In einem Blatt.",
        "An der Wurzel.",
        "Als linkes Kind der 3.",
        "Er wird gar nicht gespeichert.",
        "Unterhalb der 5."
      ],
      "answer": 1,
      "explanation": "In einem Ausdrucksbaum stehen Operatoren in den inneren Knoten und Zahlen in den Blättern. Da die Multiplikation die *letzte* Operation ist, die die beiden Teilergebnisse `(3+4)` und `5` verbindet, steht sie an der Spitze (Wurzel).",
      "weight": 3,
      "topic": "Anwendungen",
      "konzept": "Ausdrucksbäume",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Aufbau eines Ausdrucksbaums",
        "schritte": [
          "Formel: $Resultat = Term1 * Term2$.",
          "Der Haupt-Operator `*` verbindet die beiden Teile.",
          "Daher ist `*` die Wurzel.",
          "Linker Teilbaum: `+` mit Kindern 3 und 4.",
          "Rechter Teilbaum: Blatt 5."
        ]
      },
      "mini_glossary": {
        "Ausdrucksbaum": "Baum zur Darstellung mathematischer Formeln.",
        "Operator": "Funktion wie +, -, *, /.",
        "Operand": "Zahl oder Variable."
      }
    },
    {
      "question": "40. Sie haben einen Baum mit $n$ Knoten. Wie viele verschiedene einfache Pfade existieren zwischen zwei *unterschiedlichen* Blättern?",
      "options": [
        "Genau einer.",
        "Genau zwei (hin und zurück).",
        "Keiner.",
        "$n$ Pfade.",
        "$n - 1$ Pfade."
      ],
      "answer": 0,
      "explanation": "Dies ist eine Fangfrage zur Bestätigung des Grundkonzepts: In einem Baum (ungerichtet betrachtet) gibt es zwischen *jeden* zwei Knoten (also auch zwei Blättern) exakt einen eindeutigen Pfad. Die Richtung spielt meist keine Rolle für die 'Existenz' der Verbindung.",
      "weight": 3,
      "topic": "Definition & Eigenschaften",
      "konzept": "Pfad-Eindeutigkeit im Detail",
      "cognitive_level": "Analyse",
      "extended_explanation": {
        "titel": "Verbindung zweier Blätter",
        "schritte": [
          "Starten Sie bei Blatt A.",
          "Gehen Sie 'hoch' Richtung Wurzel, bis Sie den ersten gemeinsamen Vorfahren (Lowest Common Ancestor) finden.",
          "Gehen Sie von dort 'runter' zu Blatt B.",
          "Es gibt keinen anderen Weg, da es keine Querverbindungen (Zyklen) gibt."
        ]
      },
      "mini_glossary": {
        "Lowest Common Ancestor": "Der tiefste Knoten, der Vorfahre von beiden Zielknoten ist.",
        "Vorfahre": "Knoten auf dem Pfad zur Wurzel.",
        "Querverbindung": "Kante, die Äste verbindet (im Baum verboten)."
      }
    }
  ]
}
