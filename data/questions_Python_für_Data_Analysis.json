{
  "meta": {
    "title": "Python für Data Analysis (Komplettset)",
    "created": "07.12.2025 16:45",
    "target_audience": "Data Science Einsteiger mit Java-Kenntnissen",
    "question_count": 80,
    "difficulty_profile": {
      "easy": 25,
      "medium": 37,
      "hard": 18
    },
    "time_per_weight_minutes": {
      "1": 0.5,
      "2": 0.75,
      "3": 1.0
    },
    "additional_buffer_minutes": 5,
    "test_duration_minutes": 64
  },
  "questions": [
    {
      "question": "1. Welcher fundamentale Unterschied besteht zwischen Variablen in Python und Java, der für Data Science relevant ist?",
      "options": [
        "Python-Variablen sind statisch typisiert, Java-Variablen dynamisch.",
        "Python ist dynamisch typisiert; Variablen sind Referenzen auf Objekte, keine festen Typ-Container.",
        "In Python müssen Variablen immer vor der Verwendung deklariert werden.",
        "Python erlaubt keine primitiven Datentypen wie Integer oder Float."
      ],
      "answer": 1,
      "explanation": "Python ist dynamisch typisiert. Im Gegensatz zu Java, wo eine Variable `int x` nur Integer speichern kann, ist ein Variablenname in Python nur ein Label (Referenz), das auf beliebige Objekte zeigen kann.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Dynamische Typisierung",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Dynamische Typisierung", "definition": "Typüberprüfung zur Laufzeit; Variablen sind nicht an einen Typ gebunden." },
        { "term": "Referenz", "definition": "Verweis auf den Speicherort eines Objekts." }
      ]
    },
    {
      "question": "2. Wie wird in Python ein Code-Block (z. B. innerhalb einer Schleife) definiert?",
      "options": [
        "Durch geschweifte Klammern `{ }` wie in Java.",
        "Durch das Schlüsselwort `begin` und `end`.",
        "Durch Einrückung (Indentation).",
        "Durch Semikolons am Zeilenende."
      ],
      "answer": 2,
      "explanation": "Python nutzt Einrückungen (Whitespace), um Blöcke zu strukturieren. Dies erzwingt lesbaren Code und ersetzt die in Java üblichen geschweiften Klammern.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Syntax & Indentation",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Indentation", "definition": "Einrückung von Codezeilen zur Strukturierung." }
      ]
    },
    {
      "question": "3. Was ist das Ergebnis des Ausdrucks `[x**2 for x in range(4)]`?",
      "options": [
        "Eine Fehlermeldung, da die Syntax falsch ist.",
        "`[0, 1, 4, 9]`",
        "`[1, 4, 9, 16]`",
        "`{0, 1, 4, 9}`"
      ],
      "answer": 1,
      "explanation": "Dies ist eine List Comprehension. `range(4)` erzeugt 0, 1, 2, 3. Das Quadrat davon ist 0, 1, 4, 9.",
      "weight": 2,
      "topic": "Datenstrukturen",
      "concept": "List Comprehensions",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Auflösung der List Comprehension",
        "steps": [
          "Identifiziere den Generator: `range(4)` liefert die Werte 0, 1, 2, 3.",
          "Wende die Operation an: `x**2` quadriert jeden Wert.",
          "Berechne: 0²=0, 1²=1, 2²=4, 3²=9.",
          "Sammle in Liste: `[0, 1, 4, 9]`."
        ],
        "content": "List Comprehensions bieten eine kompakte Syntax, um Listen basierend auf anderen Iterables zu erstellen, und ersetzen oft mehrzeilige For-Schleifen."
      },
      "mini_glossary": [
        { "term": "List Comprehension", "definition": "Kompakte Syntax zur Erstellung von Listen." },
        { "term": "range()", "definition": "Funktion, die eine Sequenz von Zahlen generiert." }
      ]
    },
    {
      "question": "4. Welche Bibliothek ist der De-facto-Standard für numerische Berechnungen und Arrays in Python?",
      "options": [
        "Pandas",
        "NumPy",
        "Matplotlib",
        "Scikit-learn"
      ],
      "answer": 1,
      "explanation": "NumPy (Numerical Python) ist die Basisbibliothek für effiziente Arrays und mathematische Operationen.",
      "weight": 1,
      "topic": "NumPy Grundlagen",
      "concept": "Bibliotheken-Ökosystem",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "NumPy", "definition": "Bibliothek für multidimensionale Arrays und Matrizen." }
      ]
    },
    {
      "question": "5. Gegeben ist ein NumPy Array `arr = np.array([1, 2, 3])`. Was passiert bei `arr * 2`?",
      "options": [
        "Das Array wird dupliziert: `[1, 2, 3, 1, 2, 3]`.",
        "Es entsteht ein Fehler, da man Arrays nicht mit Skalaren multiplizieren kann.",
        "Jedes Element wird multipliziert: `[2, 4, 6]`.",
        "Die Länge des Arrays wird verdoppelt."
      ],
      "answer": 2,
      "explanation": "NumPy unterstützt Vektorisierung. Operationen mit Skalaren werden elementweise auf das gesamte Array angewendet (Broadcasting).",
      "weight": 2,
      "topic": "NumPy Operationen",
      "concept": "Vektorisierung",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Vektorisierung in NumPy",
        "steps": [
          "NumPy erkennt die Multiplikation eines Arrays mit einem Skalar.",
          "Der Skalar (2) wird auf jedes Element des Arrays angewendet.",
          "Rechnung: 1*2=2, 2*2=4, 3*2=6.",
          "Ergebnis ist ein neues Array gleicher Form."
        ],
        "content": "Im Gegensatz zu Java-Listen (wo man eine Schleife bräuchte) oder Python-Listen (wo `*` die Liste wiederholt), rechnet NumPy mathematisch elementweise."
      },
      "mini_glossary": [
        { "term": "Vektorisierung", "definition": "Ausführung von Operationen auf ganzen Arrays ohne explizite Schleifen." },
        { "term": "Broadcasting", "definition": "Mechanismus zur Behandlung von Arrays unterschiedlicher Form bei Operationen." }
      ]
    },
    {
      "question": "6. Sie haben ein Pandas DataFrame `df`. Mit welchem Befehl erhalten Sie eine schnelle statistische Zusammenfassung (Mittelwert, Min, Max etc.) der numerischen Spalten?",
      "options": [
        "`df.info()`",
        "`df.head()`",
        "`df.describe()`",
        "`df.stats()`"
      ],
      "answer": 2,
      "explanation": "`df.describe()` generiert deskriptive Statistiken für alle numerischen Spalten. `df.info()` zeigt Datentypen und Nicht-Null-Werte.",
      "weight": 1,
      "topic": "Pandas Grundlagen",
      "concept": "Daten-Exploration",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "DataFrame", "definition": "Zweidimensionale, tabellarische Datenstruktur in Pandas." },
        { "term": "Deskriptive Statistik", "definition": "Zusammenfassende Kennzahlen wie Mittelwert und Standardabweichung." }
      ]
    },
    {
      "question": "7. Wie wählen Sie in einem Pandas DataFrame `df` die Spalte 'Preis' aus?",
      "options": [
        "`df.get('Preis')`",
        "`df['Preis']` oder `df.Preis`",
        "`df(Preis)`",
        "`df->Preis`"
      ],
      "answer": 1,
      "explanation": "Die Standard-Syntax ist `df['Spaltenname']`. Wenn der Name keine Leerzeichen oder Sonderzeichen enthält, geht oft auch die Attribut-Schreibweise `df.Spaltenname`.",
      "weight": 1,
      "topic": "Pandas Grundlagen",
      "concept": "Spalten-Selektion",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Series", "definition": "Eindimensionales Array-ähnliches Objekt, das eine Spalte repräsentiert." }
      ]
    },
    {
      "question": "8. Gegeben ist `df` mit Index 0 bis 10. Was liefert `df.iloc[0:3]`?",
      "options": [
        "Die Zeilen mit den Index-Labels 0, 1, 2 und 3.",
        "Die Zeilen an den Positionen 0, 1 und 2.",
        "Nur die Zeile an Position 3.",
        "Eine Fehlermeldung."
      ],
      "answer": 1,
      "explanation": "`iloc` arbeitet positionsbasiert (integer-location). Wie beim Python-Slicing ist der Endwert exklusiv. Es werden die Zeilen an Position 0, 1 und 2 zurückgegeben.",
      "weight": 2,
      "topic": "Pandas Indexing",
      "concept": "iloc vs loc",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Funktionsweise von iloc",
        "steps": [
          "Verstehe `iloc`: Integer-Location (basierend auf Position, nicht Label).",
          "Analysiere den Slice `0:3`.",
          "Start: 0 (inklusive).",
          "Ende: 3 (exklusiv, typisch für Python).",
          "Ergebnis: Zeilen an Position 0, 1, 2."
        ],
        "content": "Dies ist ein häufiger Stolperstein für Umsteiger: `loc[0:3]` würde (bei numerischem Index) auch die 3 einschließen (Label-basiert), während `iloc` strikt Python-Slicing-Regeln folgt."
      },
      "mini_glossary": [
        { "term": "iloc", "definition": "Positionsbasierte Indizierung in Pandas." },
        { "term": "Slicing", "definition": "Ausschneiden eines Teilbereichs aus einer Sequenz." }
      ]
    },
    {
      "question": "9. Sie möchten Zeilen filtern, in denen die Spalte 'Alter' größer als 30 ist. Welcher Code ist korrekt?",
      "options": [
        "`df[df['Alter'] > 30]`",
        "`df.filter('Alter' > 30)`",
        "`df.where(Alter > 30)`",
        "`if df['Alter'] > 30: return df`"
      ],
      "answer": 0,
      "explanation": "Dies nennt man 'Boolean Indexing' oder 'Masking'. Der innere Ausdruck `df['Alter'] > 30` erzeugt eine Serie von Wahrheitswerten, die dann zum Filtern des DataFrames genutzt wird.",
      "weight": 2,
      "topic": "Daten-Selektion",
      "concept": "Boolean Indexing",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Boolean Masking",
        "steps": [
          "Erstelle Bedingung: `df['Alter'] > 30` ergibt eine Series aus True/False.",
          "Wende Maske an: `df[...]` nutzt diese Series.",
          "Filterung: Nur Zeilen, wo 'True' steht, bleiben erhalten.",
          "Ergebnis: Ein neuer DataFrame mit den gefilterten Daten."
        ],
        "content": "Dies ist der Standardweg in Pandas und NumPy, um Daten effizient ohne Schleifen zu filtern."
      },
      "mini_glossary": [
        { "term": "Boolean Mask", "definition": "Array aus Wahrheitswerten zur Filterung von Daten." }
      ]
    },
    {
      "question": "10. Ein DataFrame enthält `NaN` Werte. Welche Methode entfernt alle Zeilen, die mindestens einen fehlenden Wert enthalten?",
      "options": [
        "`df.fillna(0)`",
        "`df.dropna()`",
        "`df.remove_nulls()`",
        "`df.isnull()`"
      ],
      "answer": 1,
      "explanation": "`dropna()` entfernt standardmäßig alle Zeilen (`axis=0`), die irgendeinen (`how='any'`) fehlenden Wert enthalten.",
      "weight": 1,
      "topic": "Datenbereinigung",
      "concept": "Missing Values",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "NaN", "definition": "Not a Number; Platzhalter für fehlende Werte." },
        { "term": "Imputation", "definition": "Ersetzen fehlender Werte (Gegenteil von Löschen)." }
      ]
    },
    {
      "question": "11. Was bewirkt `df.groupby('Kategorie')['Umsatz'].sum()`?",
      "options": [
        "Es sortiert die Tabelle nach Kategorie und Umsatz.",
        "Es gruppiert die Daten nach Kategorie und berechnet die Summe der Umsatz-Spalte für jede Gruppe.",
        "Es addiert 'Kategorie' und 'Umsatz' zusammen.",
        "Es filtert alle Zeilen, die keinen Umsatz haben."
      ],
      "answer": 1,
      "explanation": "Dies ist das 'Split-Apply-Combine' Muster. Die Daten werden nach 'Kategorie' gesplittet, und die Summen-Funktion wird auf 'Umsatz' angewendet.",
      "weight": 2,
      "topic": "Aggregation",
      "concept": "Groupby",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Split-Apply-Combine",
        "steps": [
          "Split: Teile Daten in Gruppen basierend auf eindeutigen Werten in 'Kategorie'.",
          "Select: Wähle die Spalte 'Umsatz' in jeder Gruppe.",
          "Apply: Berechne die Summe für diese Spalte pro Gruppe.",
          "Combine: Füge Ergebnisse zu neuem DataFrame/Series zusammen."
        ],
        "content": "Ähnlich wie `GROUP BY` in SQL ist dies essenziell für aggregierte Analysen."
      },
      "mini_glossary": [
        { "term": "Aggregation", "definition": "Zusammenfassen mehrerer Werte zu einem (z. B. Summe, Mittelwert)." }
      ]
    },
    {
      "question": "12. Sie wollen eine CSV-Datei 'data.csv' einlesen. Welcher Befehl ist korrekt?",
      "options": [
        "`pd.read_file('data.csv')`",
        "`pd.import_csv('data.csv')`",
        "`pd.read_csv('data.csv')`",
        "`new DataFrame('data.csv')`"
      ],
      "answer": 2,
      "explanation": "`pd.read_csv()` ist die Standardfunktion in Pandas zum Einlesen von Comma Separated Values.",
      "weight": 1,
      "topic": "Datei-I/O",
      "concept": "Datenimport",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "CSV", "definition": "Comma Separated Values; einfaches Textformat für Tabellen." }
      ]
    },
    {
      "question": "13. In einem Boxplot ist der Median als Linie eingezeichnet. Was repräsentiert die 'Box' selbst?",
      "options": [
        "Den Bereich von Minimum bis Maximum.",
        "Den Interquartilsabstand (IQR), also den Bereich zwischen dem 25. und 75. Perzentil.",
        "Die Standardabweichung vom Mittelwert.",
        "Alle Ausreißer."
      ],
      "answer": 1,
      "explanation": "Die Box in einem Boxplot spannt sich vom 1. Quartil (Q1) bis zum 3. Quartil (Q3) und enthält somit die mittleren 50% der Daten.",
      "weight": 2,
      "topic": "Visualisierung",
      "concept": "Boxplot-Interpretation",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Aufbau eines Boxplots",
        "steps": [
          "Untere Kante der Box: Q1 (25% der Daten sind kleiner).",
          "Obere Kante der Box: Q3 (75% der Daten sind kleiner).",
          "Höhe der Box: IQR = Q3 - Q1.",
          "Linie in der Box: Median (50%)."
        ],
        "content": "Boxplots sind ideal, um Verteilungen und Ausreißer (Punkte außerhalb der 'Whisker') schnell zu erkennen."
      },
      "mini_glossary": [
        { "term": "IQR", "definition": "Interquartilsabstand; Maß für die Streuung." },
        { "term": "Perzentil", "definition": "Wert, unterhalb dessen ein bestimmter Prozentsatz der Daten liegt." }
      ]
    },
    {
      "question": "14. Sie führen folgenden Code aus: `df['A'] = df['B']; df['A'].iloc[0] = 10`. Später stellen Sie fest, dass sich auch `df['B']` geändert hat. Warum?",
      "options": [
        "Das ist ein Bug in Pandas.",
        "Pandas kopiert Daten standardmäßig immer.",
        "Dies ist eine 'SettingWithCopy'-Situation; die Zuweisung erstellte nur eine flache Kopie (View) oder Referenz.",
        "Spalte A und B teilen sich physikalisch immer den Speicher."
      ],
      "answer": 2,
      "explanation": "In Python und Pandas führen einfache Zuweisungen oft nur zu Referenzen oder Views auf denselben Speicher. Um eine unabhängige Kopie zu erhalten, muss `.copy()` verwendet werden.",
      "weight": 3,
      "topic": "Pandas Internals",
      "concept": "Views vs Copies",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Referenzverhalten analysieren",
        "steps": [
          "Zuweisung `df['A'] = df['B']` erstellt oft keine neuen Daten, sondern verweist auf dieselbe Series.",
          "Änderung in 'A' greift auf denselben Speicher zu wie 'B'.",
          "Lösung: Explizites `df['A'] = df['B'].copy()` nutzen."
        ],
        "content": "Dieses Verhalten ist für Java-Entwickler, die 'Call-by-Value' bei Primitiven gewohnt sind, eine häufige Fehlerquelle bei Objekten."
      },
      "mini_glossary": [
        { "term": "Deep Copy", "definition": "Vollständige Kopie aller Daten und Unterobjekte." },
        { "term": "View", "definition": "Sicht auf Daten, ohne den Speicher zu duplizieren." }
      ]
    },
    {
      "question": "15. Was ist der Hauptvorteil der Verwendung von `apply()` mit einer Lambda-Funktion gegenüber einer Iteration mit `for`-Schleife über Zeilen in Pandas?",
      "options": [
        "`apply()` ist immer 100x schneller als jede andere Methode.",
        "Es ist syntaktisch kürzer und oft schneller als eine naive Python-Schleife, aber langsamer als Vektorisierung.",
        "Es erlaubt Zugriff auf private Variablen.",
        "Es gibt keinen Unterschied."
      ],
      "answer": 1,
      "explanation": "`apply()` ist performanter als eine explizite `for`-Schleife in reinem Python, da der Loop intern in C optimiert ist, aber es ist immer noch langsamer als echte Vektorisierung (direkte Spalten-Operationen).",
      "weight": 2,
      "topic": "Performance",
      "concept": "Apply vs Loops",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Performance-Hierarchie",
        "steps": [
          "1. Platz: Vektorisierung (NumPy/Pandas native Ops).",
          "2. Platz: `apply()` (interner Iterator).",
          "3. Platz: `iterrows()` (langsamer Iterator).",
          "4. Platz: Manuelle Index-Schleife (sehr langsam)."
        ],
        "content": "Verwenden Sie `apply` nur, wenn keine vektorisierte Lösung (wie `df['A'] + df['B']`) möglich ist."
      },
      "mini_glossary": [
        { "term": "Lambda-Funktion", "definition": "Anonyme kleine Funktion, oft inline definiert." }
      ]
    },
    {
      "question": "16. Sie haben zwei DataFrames `df1` (Kunden) und `df2` (Bestellungen). Sie wollen diese verbinden, sodass alle Kunden enthalten sind, auch wenn sie keine Bestellung haben. Welchen Join-Typ wählen Sie?",
      "options": [
        "Inner Join",
        "Left Join (wenn df1 links steht)",
        "Right Join (wenn df1 links steht)",
        "Cross Join"
      ],
      "answer": 1,
      "explanation": "Ein Left Join behält alle Schlüssel aus der linken Tabelle (`df1`) und ergänzt Daten aus der rechten Tabelle (`df2`) dort, wo Treffer sind. Sonst entstehen `NaN`.",
      "weight": 2,
      "topic": "Daten-Zusammenführung",
      "concept": "Merge/Join Logik",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Join-Logik anwenden",
        "steps": [
          "Ziel: Alle Datensätze aus `df1` (Kunden) behalten.",
          "Strategie: `df1` als linke Tabelle setzen.",
          "Join-Typ: `how='left'`.",
          "Ergebnis: Kunden ohne Bestellung haben `NaN` in den Bestellspalten."
        ],
        "content": "Dies entspricht `LEFT OUTER JOIN` in SQL. Ein Inner Join würde Kunden ohne Bestellung verwerfen."
      },
      "mini_glossary": [
        { "term": "Merge", "definition": "Zusammenführen von DataFrames basierend auf Schlüsseln." }
      ]
    },
    {
      "question": "17. Welche Aussage zur Speicherverwaltung von Pandas 'category' Datentyp ist korrekt?",
      "options": [
        "Er verbraucht mehr Speicher als 'object' (String), da er Metadaten speichert.",
        "Er ist nur für numerische Daten geeignet.",
        "Er spart signifikant Speicher bei String-Spalten mit wenigen eindeutigen Werten (geringe Kardinalität).",
        "Er verlangsamt Gruppierungsoperationen."
      ],
      "answer": 2,
      "explanation": "Der Datentyp 'category' speichert die Strings nur einmal in einer Lookup-Tabelle und verwendet im DataFrame kleine Integer-Codes. Bei vielen Wiederholungen spart das massiv Speicher.",
      "weight": 3,
      "topic": "Performance & Speicher",
      "concept": "Categorical Data",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Speicheroptimierung mit Categories",
        "steps": [
          "Analyse: Spalte 'Farbe' hat 1 Mio Zeilen, aber nur 'Rot', 'Grün', 'Blau'.",
          "String (Object): Speichert 1 Mio mal den String.",
          "Category: Speichert 3 Strings + 1 Mio kleine Integers (0, 1, 2).",
          "Effekt: Drastische Reduktion des RAM-Verbrauchs."
        ],
        "content": "Zusätzlich beschleunigt 'category' oft `groupby` und Sortieroperationen."
      },
      "mini_glossary": [
        { "term": "Kardinalität", "definition": "Anzahl der eindeutigen Werte in einer Menge." }
      ]
    },
    {
      "question": "18. Was ist das Ergebnis von `np.arange(0, 10, 2)`?",
      "options": [
        "`[0, 2, 4, 6, 8, 10]`",
        "`[0, 2, 4, 6, 8]`",
        "`[2, 4, 6, 8]`",
        "`[0, 1, 2, ... 9]`"
      ],
      "answer": 1,
      "explanation": "`arange(start, stop, step)` generiert Werte von Start bis exklusive Stop mit der Schrittweite Step. 10 ist exklusiv.",
      "weight": 1,
      "topic": "NumPy Grundlagen",
      "concept": "Array Erstellung",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "arange", "definition": "Array Range; NumPy-Äquivalent zu Python range()." }
      ]
    },
    {
      "question": "19. Sie haben Zeitreihendaten als String '2023-01-01'. Wie konvertieren Sie die ganze Spalte effizient in echte Datumsobjekte?",
      "options": [
        "Mit einer For-Schleife und `datetime.parse()`.",
        "`pd.to_datetime(df['Spalte'])`",
        "`df['Spalte'].astype('date')`",
        "`df.convert_objects()`"
      ],
      "answer": 1,
      "explanation": "`pd.to_datetime()` ist der leistungsfähige Parser in Pandas, der ganze Spalten intelligent und schnell in Timestamp-Objekte umwandelt.",
      "weight": 1,
      "topic": "Datenbereinigung",
      "concept": "Datentyp-Konvertierung",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Timestamp", "definition": "Zeitstempel-Objekt in Pandas." }
      ]
    },
    {
      "question": "20. Welche Bibliothek baut auf Matplotlib auf und bietet eine einfachere Syntax für statistische Grafiken sowie schönere Default-Styles?",
      "options": [
        "NumPy",
        "Seaborn",
        "SciPy",
        "TensorFlow"
      ],
      "answer": 1,
      "explanation": "Seaborn ist eine High-Level-Visualisierungsbibliothek, die eng mit Pandas DataFrames integriert ist und Matplotlib erweitert.",
      "weight": 1,
      "topic": "Visualisierung",
      "concept": "Bibliotheken",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Seaborn", "definition": "Bibliothek für statistische Datenvisualisierung." }
      ]
    },
    {
      "question": "21. Sie analysieren Verkaufsdaten. `df.groupby('Produkt')['Umsatz'].mean()` liefert Durchschnittswerte. Aber die Ergebnisse wirken verzerrt durch einige extrem hohe Verkäufe. Welche Aggregation ist robuster gegen Ausreißer?",
      "options": [
        "`sum()`",
        "`median()`",
        "`std()`",
        "`max()`"
      ],
      "answer": 1,
      "explanation": "Der Median (Zentralwert) ist im Gegensatz zum Mittelwert (Mean) robust gegenüber extremen Ausreißern, da er nur auf der Rangfolge basiert.",
      "weight": 3,
      "topic": "Statistik & Analyse",
      "concept": "Robuste Statistiken",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Median vs Mean",
        "steps": [
          "Szenario: Werte 1, 2, 3, 100.",
          "Mittelwert: (106)/4 = 26.5 (stark beeinflusst durch 100).",
          "Median: Zwischen 2 und 3 => 2.5 (repräsentiert die 'Mitte' besser).",
          "Analyse: Nutzen Sie Median bei schiefen Verteilungen."
        ],
        "content": "Bei Data Science ist die Wahl der richtigen Kennzahl entscheidend für die korrekte Interpretation der Daten."
      },
      "mini_glossary": [
        { "term": "Robustheit", "definition": "Unempfindlichkeit statistischer Maßzahlen gegenüber Ausreißern." }
      ]
    },
    {
      "question": "22. Was bedeutet `axis=1` in Operationen wie `df.drop('col', axis=1)` oder `df.sum(axis=1)`?",
      "options": [
        "Operation entlang der Zeilen (vertikal).",
        "Operation entlang der Spalten (horizontal).",
        "Operation auf der dritten Dimension.",
        "Es gibt keinen Unterschied zu `axis=0`."
      ],
      "answer": 1,
      "explanation": "`axis=0` bezieht sich auf den Index (Zeilen), `axis=1` bezieht sich auf die Spalten. `drop(..., axis=1)` löscht also eine Spalte.",
      "weight": 2,
      "topic": "Pandas Grundlagen",
      "concept": "Achsen-Logik",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Achsen verstehen",
        "steps": [
          "Axis 0: Bewegt sich 'nach unten' (über Zeilen hinweg). `sum(axis=0)` summiert Spalten.",
          "Axis 1: Bewegt sich 'nach rechts' (über Spalten hinweg). `sum(axis=1)` summiert Werte einer Zeile.",
          "Eselsbrücke: 1 sieht aus wie ein stehender Strich (Spalte) -> beeinflusst Spalten."
        ],
        "content": "Die korrekte Achsenwahl ist essenziell für Aggregationen und Manipulationen."
      },
      "mini_glossary": [
        { "term": "Axis", "definition": "Dimension in einem Array/DataFrame (0=Zeilen, 1=Spalten)." }
      ]
    },
    {
      "question": "23. Sie wollen zwei DataFrames vertikal untereinander hängen (konkatenieren). Welcher Befehl?",
      "options": [
        "`pd.merge([df1, df2])`",
        "`pd.concat([df1, df2], axis=0)`",
        "`pd.join(df1, df2)`",
        "`df1.append_rows(df2)`"
      ],
      "answer": 1,
      "explanation": "`pd.concat()` ist die universelle Funktion zum Aneinanderhängen. `axis=0` (Standard) stapelt vertikal, `axis=1` würde sie nebeneinander stellen.",
      "weight": 2,
      "topic": "Daten-Zusammenführung",
      "concept": "Konkatenation",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Daten stapeln",
        "steps": [
          "Identifiziere Aufgabe: Tabellen 'untereinander' kleben.",
          "Wähle Tool: `pd.concat()` nimmt eine Liste von Objekten.",
          "Wähle Richtung: `axis=0` (Zeilen hinzufügen).",
          "Prüfung: Spaltennamen sollten idealerweise übereinstimmen."
        ],
        "content": "`merge` ist für SQL-artige Joins (Spalten verbinden), `concat` für physisches Zusammenfügen."
      },
      "mini_glossary": [
        { "term": "Konkatenation", "definition": "Verkettung von Listen oder Arrays." }
      ]
    },
    {
      "question": "24. Welche Python-Struktur entspricht am ehesten einer `HashMap` in Java?",
      "options": [
        "List `[]`",
        "Tuple `()`",
        "Dictionary `{}`",
        "Set `{}`"
      ],
      "answer": 2,
      "explanation": "Ein Dictionary (`dict`) speichert Key-Value-Paare und bietet O(1) Zugriff auf Schlüssel, genau wie eine HashMap.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Datenstrukturen Vergleich",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Dictionary", "definition": "Ungeordnete Sammlung von Schlüssel-Wert-Paaren." }
      ]
    },
    {
      "question": "25. Ein Histogramm zeigt eine 'Linksschiefe' (left-skewed / negative skew). Wo liegt der Mittelwert im Vergleich zum Median?",
      "options": [
        "Mittelwert > Median",
        "Mittelwert < Median",
        "Mittelwert == Median",
        "Kann man nicht sagen."
      ],
      "answer": 1,
      "explanation": "Bei einer Linksschiefe (langer Schwanz nach links, zu kleinen Werten) ziehen die kleinen Ausreißer den Mittelwert nach unten. Der Median bleibt weiter rechts.",
      "weight": 3,
      "topic": "Statistik",
      "concept": "Verteilungsformen",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Schiefe Verteilungen",
        "steps": [
          "Visualisiere: Der 'Berg' ist rechts, der flache Ausläufer links.",
          "Einfluss: Ausreißer im linken Ausläufer (sehr kleine Werte).",
          "Mittelwert: Reagiert stark, wandert nach links.",
          "Median: Bleibt im Zentrum der Masse (rechts vom Mittelwert)."
        ],
        "content": "Verstehen der Schiefe ist wichtig, um zu entscheiden, ob der Mittelwert eine gute Kennzahl ist."
      },
      "mini_glossary": [
        { "term": "Skewness", "definition": "Schiefe einer Wahrscheinlichkeitsverteilung." }
      ]
    },
    {
      "question": "26. Warum ist `for row in df.iterrows(): ...` oft eine schlechte Idee bei großen Datensätzen?",
      "options": [
        "Es ist syntaktisch falsch.",
        "Es ist extrem langsam, da Pandas-Optimierungen umgangen werden und für jede Zeile ein Series-Objekt erstellt wird.",
        "Es führt zu Speicherüberlauf.",
        "Es verändert die Daten ungewollt."
      ],
      "answer": 1,
      "explanation": "`iterrows()` iteriert in Python-Geschwindigkeit und erzeugt Overhead durch Objekterstellung. Vektorisierung ist um Größenordnungen schneller.",
      "weight": 2,
      "topic": "Performance",
      "concept": "Anti-Patterns",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Vermeidung von iterrows",
        "steps": [
          "Problem: Python-Loops sind langsam bei Millionen Durchläufen.",
          "Problem 2: `iterrows` konvertiert jede Zeile in eine neue Series (Overhead).",
          "Lösung: Nutze Spaltenoperationen (`df['a'] + df['b']`)."
        ],
        "content": "Iteration sollte in Pandas das letzte Mittel sein, nicht das erste."
      },
      "mini_glossary": [
        { "term": "Overhead", "definition": "Zusätzlicher Ressourcenaufwand für Verwaltung." }
      ]
    },
    {
      "question": "27. Sie verwenden `df.pivot_table(index='Datum', columns='Produkt', values='Umsatz')`. Was passiert, wenn es für ein Datum und Produkt mehrere Umsatz-Einträge gibt?",
      "options": [
        "Fehler.",
        "Es wird standardmäßig der Mittelwert (`mean`) der Werte berechnet.",
        "Es wird der erste Wert genommen.",
        "Es wird der letzte Wert genommen."
      ],
      "answer": 1,
      "explanation": "`pivot_table` hat einen Parameter `aggfunc`, der standardmäßig auf `'mean'` gesetzt ist (anders als einfaches `pivot`, das keine Duplikate erlaubt).",
      "weight": 2,
      "topic": "Reshaping",
      "concept": "Pivoting",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Pivot vs Pivot Table",
        "steps": [
          "Situation: Mehrere Werte pro Zelle (Datum/Produkt Kombination).",
          "Notwendigkeit: Aggregation (Zusammenfassung).",
          "Lösung: `pivot_table` aggregiert automatisch (default mean).",
          "Alternative: `pivot` würde einen 'Duplicate index' Fehler werfen."
        ],
        "content": "Pivoting wandelt 'lange' Formate (Datenbank-Style) in 'breite' Formate (Excel-Style) um."
      },
      "mini_glossary": [
        { "term": "Pivot", "definition": "Drehen von Daten; Umwandlung von Zeilenwerten in Spaltenüberschriften." }
      ]
    },
    {
      "question": "28. Welcher Datentyp wird von Pandas verwendet, um fehlende numerische Werte (NaN) zu speichern, und was ist die Konsequenz für Integer-Spalten (vor Pandas 1.0)?",
      "options": [
        "`null`; Integer Spalten bleiben Integer.",
        "`NaN` (float); Integer-Spalten werden zwangsweise zu Float konvertiert.",
        "`None`; keine Auswirkung.",
        "`-1`; als Platzhalter."
      ],
      "answer": 1,
      "explanation": "Traditionell basiert `NaN` auf dem IEEE 754 Floating Point Standard. Daher mussten Integer-Spalten mit fehlenden Werten zu Float gecastet werden (z. B. wird 5 zu 5.0).",
      "weight": 3,
      "topic": "Datentypen",
      "concept": "NaN und Integers",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Das Int-NaN Problem",
        "steps": [
          "Ursache: Hardware-NaN existiert nur für Floats.",
          "Effekt: Sobald ein `NaN` in eine Int-Spalte kommt, castet Pandas alles zu Float.",
          "Neuere Lösung: Pandas führte 'Int64' (nullable int) ein, um dies zu umgehen.",
          "Analyse: Wichtig beim Einlesen von IDs, die plötzlich Kommazahlen sind."
        ],
        "content": "Achten Sie darauf, wenn IDs plötzlich '.0' am Ende haben."
      },
      "mini_glossary": [
        { "term": "IEEE 754", "definition": "Standard für Gleitkommaarithmetik." }
      ]
    },
    {
      "question": "29. Wie erstellen Sie eine Kopie eines DataFrames, bei der Änderungen NICHT auf das Original zurückwirken?",
      "options": [
        "`df2 = df`",
        "`df2 = df.copy()`",
        "`df2 = new DataFrame(df)`",
        "`df2 = df[:]`"
      ],
      "answer": 1,
      "explanation": "`df.copy()` erstellt eine 'Deep Copy' (standardmäßig). `df2 = df` kopiert nur die Referenz.",
      "weight": 1,
      "topic": "Pandas Grundlagen",
      "concept": "Kopieren",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Assignment", "definition": "Zuweisung; in Python meist Referenzkopie." }
      ]
    },
    {
      "question": "30. Was ist der Unterschied zwischen einer Liste `[1, 2]` und einem Tupel `(1, 2)` in Python?",
      "options": [
        "Listen sind immutable (unveränderlich), Tupel sind mutable.",
        "Tupel sind immutable (unveränderlich), Listen sind mutable.",
        "Listen können nur Zahlen enthalten.",
        "Tupel sind langsamer."
      ],
      "answer": 1,
      "explanation": "Tupel sind unveränderlich (immutable). Nach der Erstellung können keine Elemente hinzugefügt oder geändert werden. Listen sind dynamisch veränderbar.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Immutability",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Mutable", "definition": "Veränderbares Objekt." },
        { "term": "Immutable", "definition": "Unveränderbares Objekt nach Erstellung." }
      ]
    },
    {
      "question": "31. Sie haben eine Funktion `def process(data=[]): ...`. Warum ist dieser Default-Parameter gefährlich?",
      "options": [
        "Leere Listen sind in Python nicht erlaubt.",
        "Der Default-Wert wird nur einmal bei der Definition ausgewertet (mutable default argument trap). Alle Aufrufe teilen sich dieselbe Liste.",
        "Es verursacht einen Syntaxfehler.",
        "Die Typisierung ist unklar."
      ],
      "answer": 1,
      "explanation": "Dies ist ein klassischer Python-Fallstrick. Wenn die Funktion die Liste ändert, behält sie diese Änderungen bei folgenden Aufrufen, da das Listen-Objekt nur einmal erstellt wird.",
      "weight": 3,
      "topic": "Python Advanced",
      "concept": "Mutable Default Arguments",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Mutable Defaults Falle",
        "steps": [
          "Definition: `def f(x=[]): x.append(1); print(x)`",
          "1. Aufruf: `f()` -> `[1]`",
          "2. Aufruf: `f()` -> `[1, 1]` (NICHT `[1]`!)",
          "Lösung: Nutze `def f(x=None): if x is None: x = []`"
        ],
        "content": "In Java gibt es dieses Verhalten nicht, da Parameter anders behandelt werden. In Python ist die Funktionsdefinition ausführbarer Code."
      },
      "mini_glossary": [
        { "term": "Default Argument", "definition": "Standardwert für einen Funktionsparameter." }
      ]
    },
    {
      "question": "32. Welche Methode nutzen Sie, um Strings in einer Pandas-Series zu bearbeiten, z. B. alle auf Kleinbuchstaben zu setzen?",
      "options": [
        "Loop über alle Elemente.",
        "`df['col'].str.lower()`",
        "`df['col'].lower()`",
        "`lower(df['col'])`"
      ],
      "answer": 1,
      "explanation": "Pandas bietet den `.str` Accessor, der vektorisierte String-Operationen auf Series-Objekten ermöglicht.",
      "weight": 2,
      "topic": "Textverarbeitung",
      "concept": "String Accessor",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Der .str Accessor",
        "steps": [
          "Problem: Methoden wie `.lower()` existieren nicht direkt auf der Series.",
          "Lösung: Zugriff über `.str` macht String-Methoden verfügbar.",
          "Anwendung: `series.str.upper()`, `series.str.contains()`, etc.",
          "Vorteil: Behandelt `NaN` automatisch korrekt."
        ],
        "content": "Dies ist analog zum `.dt` Accessor für Datumsangaben."
      },
      "mini_glossary": [
        { "term": "Accessor", "definition": "Schnittstelle für spezifische Datentyp-Funktionen (str, dt, cat)." }
      ]
    },
    {
      "question": "33. Sie plotten zwei Variablen gegeneinander und sehen eine Punktewolke, die sich um eine Gerade von unten links nach oben rechts gruppiert. Was sagt die Korrelation aus?",
      "options": [
        "Korrelation nahe -1.",
        "Korrelation nahe 0.",
        "Korrelation nahe +1.",
        "Keine Korrelation."
      ],
      "answer": 2,
      "explanation": "Eine steigende Gerade deutet auf eine starke positive lineare Beziehung hin, also einen Korrelationskoeffizienten (Pearson) nahe +1.",
      "weight": 2,
      "topic": "Statistik",
      "concept": "Korrelation",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Korrelation interpretieren",
        "steps": [
          "Positive Steigung: Wenn X steigt, steigt Y -> Positiv.",
          "Eng an der Linie: Starke Beziehung -> Nahe 1.",
          "Streuung: Punktewolke -> Schwächere Korrelation.",
          "Schlussfolgerung: +1 ist perfekt linear steigend."
        ],
        "content": "Korrelation impliziert keine Kausalität, beschreibt aber die Stärke des linearen Zusammenhangs."
      },
      "mini_glossary": [
        { "term": "Pearson Korrelation", "definition": "Maß für den linearen Zusammenhang (-1 bis +1)." }
      ]
    },
    {
      "question": "34. Wie laden Sie ein Modul 'matplotlib.pyplot' standardkonform, um Tipparbeit zu sparen?",
      "options": [
        "`import matplotlib.pyplot`",
        "`import matplotlib.pyplot as plt`",
        "`include matplotlib.pyplot`",
        "`from matplotlib import pyplot`"
      ],
      "answer": 1,
      "explanation": "`import ... as ...` erlaubt Aliasse. `plt` ist die universelle Konvention für pyplot.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Import Konventionen",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Alias", "definition": "Kurzname für ein importiertes Modul." }
      ]
    },
    {
      "question": "35. Was passiert, wenn Sie `set([1, 2, 2, 3])` aufrufen?",
      "options": [
        "Ein Fehler.",
        "Es entsteht `{1, 2, 2, 3}`.",
        "Es entsteht `{1, 2, 3}` (Duplikate entfernt).",
        "Es entsteht eine sortierte Liste `[1, 2, 3]`."
      ],
      "answer": 2,
      "explanation": "Ein Set ist eine Menge eindeutiger Elemente. Bei der Erstellung werden Duplikate automatisch verworfen.",
      "weight": 2,
      "topic": "Python Datenstrukturen",
      "concept": "Sets",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Eigenschaften von Sets",
        "steps": [
          "Eingabe: Liste mit Duplikaten.",
          "Konvertierung zu Set: Prüft Hash-Werte.",
          "Filterung: Behält jeden Hash nur einmal.",
          "Ergebnis: Menge der Unique Values."
        ],
        "content": "Sets sind extrem nützlich, um schnell die Menge der eindeutigen Elemente in einer Liste zu finden."
      },
      "mini_glossary": [
        { "term": "Set", "definition": "Menge eindeutiger Elemente ohne feste Ordnung." }
      ]
    },
    {
      "question": "36. Ein Machine Learning Modell zeigt auf den Trainingsdaten fast 100% Genauigkeit, aber auf den Testdaten nur 60%. Welches Problem liegt wahrscheinlich vor?",
      "options": [
        "Underfitting",
        "Overfitting",
        "Falsche Daten",
        "Zu wenig Trainingsdaten"
      ],
      "answer": 1,
      "explanation": "Overfitting (Überanpassung) bedeutet, dass das Modell die Trainingsdaten (inkl. Rauschen) 'auswendig gelernt' hat, aber nicht auf neue Daten generalisieren kann.",
      "weight": 3,
      "topic": "Data Science Konzepte",
      "concept": "Overfitting",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Overfitting Diagnose",
        "steps": [
          "Symptom: Hohe Diskrepanz zwischen Training- und Test-Score.",
          "Ursache: Modell ist zu komplex für die Datenmenge.",
          "Vergleich: Wie ein Schüler, der die Lösungen auswendig lernt, aber das Konzept nicht versteht.",
          "Gegenmaßnahme: Regularisierung, mehr Daten, einfacheres Modell."
        ],
        "content": "Dies ist eines der zentralen Probleme im Machine Learning."
      },
      "mini_glossary": [
        { "term": "Generalisierung", "definition": "Fähigkeit eines Modells, auf unbekannten Daten gute Ergebnisse zu liefern." }
      ]
    },
    {
      "question": "37. Wie greifen Sie auf das letzte Element einer Liste `lst` zu?",
      "options": [
        "`lst[len(lst)]`",
        "`lst[-1]`",
        "`lst.last()`",
        "`lst[end]`"
      ],
      "answer": 1,
      "explanation": "Python unterstützt negative Indizierung. `-1` referenziert das letzte Element, `-2` das vorletzte usw.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "Negative Indexing",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Index", "definition": "Position eines Elements in einer Sequenz." }
      ]
    },
    {
      "question": "38. Sie haben eine Spalte mit Werten '100 USD', '200 USD'. Um damit zu rechnen, müssen Sie ' USD' entfernen und in Zahlen umwandeln. Welche Kette ist am sinnvollsten?",
      "options": [
        "`df['Preis'].str.replace(' USD', '').astype(float)`",
        "`df['Preis'].replace(' USD', '').to_numeric()`",
        "`df['Preis'].trim().int()`",
        "Manuelle Schleife."
      ],
      "answer": 0,
      "explanation": "Zuerst String-Operation (`str.replace`), um den Text zu bereinigen, dann Typ-Konvertierung (`astype`).",
      "weight": 2,
      "topic": "Datenbereinigung",
      "concept": "Method Chaining",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Cleaning Pipeline",
        "steps": [
          "1. Zugriff auf String-Methoden: `.str`.",
          "2. Ersetzen: `.replace(' USD', '')` entfernt Suffix.",
          "3. Ergebnis ist immer noch String ('100').",
          "4. Konvertierung: `.astype(float)` macht daraus Zahl (100.0)."
        ],
        "content": "Das Verketten von Methoden (Chaining) macht den Code lesbar und kompakt."
      },
      "mini_glossary": [
        { "term": "Casting", "definition": "Änderung des Datentyps einer Variable." }
      ]
    },
    {
      "question": "39. Was ist der Unterschied zwischen `__init__` in Python und einem Konstruktor in Java?",
      "options": [
        "Es gibt keinen Unterschied.",
        "`__init__` erstellt das Objekt nicht, es initialisiert es nur. Das Objekt wird vorher durch `__new__` erstellt.",
        "`__init__` muss immer einen Rückgabewert haben.",
        "Java hat keine Konstruktoren."
      ],
      "answer": 1,
      "explanation": "Technisch gesehen ist `__new__` der Konstruktor, der den Speicher allokiert. `__init__` ist der Initialisierer, der das bereits erstellte Objekt (`self`) konfiguriert. In der Praxis wird `__init__` aber oft wie ein Konstruktor genutzt.",
      "weight": 3,
      "topic": "Python OOP",
      "concept": "Objekt-Erstellung",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Python Objekt-Lifecycle",
        "steps": [
          "1. `__new__`: Statische Methode, erstellt Instanz.",
          "2. `__init__`: Instanzmethode, setzt Attribute.",
          "Java: `new` Operator macht beides in einem Schritt (allokieren + Konstruktor aufrufen).",
          "Relevanz: Wichtig bei Vererbung von unveränderlichen Typen (wie str, int)."
        ],
        "content": "Für die meisten Data Science Anwendungen reicht `__init__`, aber das Verständnis ist wichtig für tiefere Python-Kenntnisse."
      },
      "mini_glossary": [
        { "term": "Self", "definition": "Referenz auf die aktuelle Instanz (analog zu `this` in Java)." }
      ]
    },
    {
      "question": "40. Welche Datenstruktur eignet sich am besten, um die Häufigkeit von Wörtern in einem Text zu zählen?",
      "options": [
        "List",
        "Set",
        "Dictionary (oder `collections.Counter`)",
        "Tuple"
      ],
      "answer": 2,
      "explanation": "Ein Dictionary mappt Wort -> Anzahl. `collections.Counter` ist eine spezialisierte Subklasse dafür.",
      "weight": 2,
      "topic": "Standard Library",
      "concept": "Counter",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Zählen mit HashMaps",
        "steps": [
          "Idee: Schlüssel ist das Wort, Wert ist der Zähler.",
          "Algorithmus: Iteriere über Text, wenn Wort existiert: count++, sonst count=1.",
          "Python Shortcut: `Counter(wort_liste)` macht dies automatisch."
        ],
        "content": "In Data Science (NLP) ist das Zählen von Tokens ('Bag of Words') ein fundamentaler Schritt."
      },
      "mini_glossary": [
        { "term": "NLP", "definition": "Natural Language Processing; Verarbeitung natürlicher Sprache." }
      ]
    },
    {
      "question": "41. Betrachten Sie folgenden Code. Was gibt er aus?\n\n```python\n1: daten = [10, 20, 30, 40, 50]\n2: print(daten[1:4])\n```",
      "options": [
        "`[10, 20, 30]`",
        "`[20, 30, 40, 50]`",
        "`[20, 30, 40]`",
        "Einen `IndexOutOfBounds` Fehler."
      ],
      "answer": 2,
      "explanation": "Python Slicing ist inklusiv beim Startindex (1 entspricht dem zweiten Element '20') und exklusiv beim Endindex (4 entspricht dem fünften Element, wird also nicht mehr eingeschlossen). Indizes sind 1, 2, 3.",
      "weight": 1,
      "topic": "Python Grundlagen",
      "concept": "List Slicing",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Slicing", "definition": "Syntax `[start:stop:step]` zum Extrahieren von Teilen." }
      ]
    },
    {
      "question": "42. Welches Problem tritt in diesem Code auf?\n\n```python\n1: import pandas as pd\n2: df = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\n3: maske = (df['A'] > 1) and (df['B'] < 5)\n```",
      "options": [
        "Die Syntax ist korrekt.",
        "Python kennt kein `and`, man muss `&&` nutzen.",
        "Für Pandas-Series muss der bitweise Operator `&` verwendet werden, da `and` mehrdeutig ist.",
        "Die Klammern sind überflüssig und verursachen den Fehler."
      ],
      "answer": 2,
      "explanation": "Der Python-Operator `and` erwartet einen einzelnen Wahrheitswert (True/False). Da Pandas-Series viele Werte enthalten, weiß Python nicht, ob die ganze Serie 'Wahr' ist. Man muss den bitweisen Operator `&` für elementweise Vergleiche nutzen.",
      "weight": 2,
      "topic": "Pandas Logik",
      "concept": "Bitwise Operators",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Boolean Operators in Pandas",
        "steps": [
          "Problem: `and` prüft `bool(Series)`, was einen `ValueError` wirft.",
          "Lösung: `&` führt die Operation elementweise (Zeile für Zeile) aus.",
          "Wichtig: Klammern um die Bedingungen `(A > 1) & (B < 5)` sind zwingend wegen der Operator-Priorität."
        ],
        "content": "Ein klassischer Fehler für Java-Entwickler, die `&&` oder `and` gewohnt sind."
      },
      "mini_glossary": [
        { "term": "Ambiguity Error", "definition": "Fehler, wenn der Wahrheitsgehalt einer Array-Struktur nicht eindeutig ist." }
      ]
    },
    {
      "question": "43. Was passiert bei der Ausführung dieses Codes?\n\n```python\n1: tupel = (1, 2, 3)\n2: tupel[1] = 5\n3: print(tupel)\n```",
      "options": [
        "Ausgabe: `(1, 5, 3)`",
        "Ausgabe: `[1, 5, 3]`",
        "TypeError: 'tuple' object does not support item assignment",
        "Der Code läuft, aber das Tupel bleibt unverändert."
      ],
      "answer": 2,
      "explanation": "Tupel sind in Python unveränderlich (immutable). Man kann Elemente nach der Erstellung nicht mehr ändern.",
      "weight": 1,
      "topic": "Python Datentypen",
      "concept": "Immutability",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "TypeError", "definition": "Fehler, wenn eine Operation auf einen unpassenden Datentyp angewendet wird." }
      ]
    },
    {
      "question": "44. Finden Sie den Logikfehler in dieser Funktion:\n\n```python\n1: def add_item(item, liste=[]):\n2:     liste.append(item)\n3:     return liste\n4:\n5: print(add_item('A'))\n6: print(add_item('B'))\n```",
      "options": [
        "Zeile 5 gibt `['A']` aus, Zeile 6 gibt `['B']` aus.",
        "Zeile 5 gibt `['A']` aus, Zeile 6 gibt `['A', 'B']` aus.",
        "Es tritt ein Fehler auf, weil `liste` nicht typisiert ist.",
        "Zeile 6 überschreibt Zeile 5, beide geben `['B']` aus."
      ],
      "answer": 1,
      "explanation": "Die Liste im Default-Parameter wird nur *einmal* bei der Definition erstellt. Beide Funktionsaufrufe teilen sich dieselbe Listen-Instanz. Das zweite Element wird an die *bestehende* Liste angehängt.",
      "weight": 3,
      "topic": "Python Funktionen",
      "concept": "Mutable Default Arguments",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Gefährliche Default-Werte",
        "steps": [
          "Definiert: `liste` wird im Speicher angelegt (ID: 123).",
          "Aufruf 1: `add_item('A')` nutzt ID 123 -> `['A']`.",
          "Aufruf 2: `add_item('B')` nutzt immer noch ID 123 (welche bereits `['A']` enthält) -> `['A', 'B']`.",
          "Fix: `def add_item(item, liste=None): if liste is None: liste = []`."
        ],
        "content": "Dies ist anders als in Java, wo Default-Parameter so nicht existieren oder per Overloading gelöst werden."
      },
      "mini_glossary": [
        { "term": "Side Effect", "definition": "Ungewollte Änderung des Zustands außerhalb des lokalen Scopes." }
      ]
    },
    {
      "question": "45. Was bewirkt dieser List-Comprehension Code?\n\n```python\n1: zahlen = [1, 2, 3, 4, 5]\n2: res = [x for x in zahlen if x % 2 == 0]\n```",
      "options": [
        "Er quadriert alle geraden Zahlen.",
        "Er filtert die Liste und behält nur gerade Zahlen: `[2, 4]`.",
        "Er erstellt eine Liste von Booleans: `[False, True, False, True, False]`.",
        "Er gibt Syntaxfehler zurück."
      ],
      "answer": 1,
      "explanation": "Der Teil `if x % 2 == 0` wirkt als Filter. Nur Elemente, die die Bedingung erfüllen, landen in der neuen Liste `res`.",
      "weight": 2,
      "topic": "Python Syntax",
      "concept": "Filtering List Comprehension",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Filter-Logik",
        "steps": [
          "Iteration: Gehe durch `zahlen`.",
          "Prüfung: Ist Element durch 2 teilbar?",
          "Selektion: Wenn ja, nimm es auf.",
          "Ergebnis: Eine neue Liste mit der Teilmenge."
        ],
        "content": "Dies entspricht in Java etwa: `stream().filter(x -> x % 2 == 0).collect(toList())`."
      },
      "mini_glossary": [
        { "term": "Modulo", "definition": "Operator `%`, gibt den Rest einer Division zurück." }
      ]
    },
    {
      "question": "46. Warum wirft dieser Pandas-Code eine Warnung (SettingWithCopyWarning)?\n\n```python\n1: df_subset = df[df['Age'] > 50]\n2: df_subset['Status'] = 'Senior'\n```",
      "options": [
        "Weil 'Senior' ein String ist und 'Status' numerisch sein sollte.",
        "Weil Pandas nicht weiß, ob `df_subset` eine Kopie oder eine Sicht (View) auf `df` ist, und die Änderung evtl. nicht im Original ankommt.",
        "Weil man neuen Spalten keine Werte zuweisen darf.",
        "Der Code ist syntaktisch falsch und läuft gar nicht."
      ],
      "answer": 1,
      "explanation": "`df[df['Age'] > 50]` könnte eine View zurückgeben. Eine Zuweisung darauf ist riskant. Pandas warnt, dass man explizit `.copy()` nutzen sollte, wenn man eine eigene Tabelle will, oder `.loc` auf dem Original nutzen sollte.",
      "weight": 3,
      "topic": "Pandas Internals",
      "concept": "SettingWithCopy",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Chained Indexing vermeiden",
        "steps": [
          "Schritt 1: `df[...]` erzeugt ein temporäres Objekt (View oder Copy).",
          "Schritt 2: `['Status'] = ...` modifiziert dieses temporäre Objekt.",
          "Konsequenz: Die Änderung geht oft verloren oder ist ineffizient.",
          "Lösung: `df.loc[df['Age'] > 50, 'Status'] = 'Senior'`."
        ],
        "content": "Dies ist eine der häufigsten Warnungen in Pandas."
      },
      "mini_glossary": [
        { "term": "Chained Assignment", "definition": "Zuweisung, die auf das Ergebnis einer vorherigen Indizierung folgt (z.B. `df[][]=`)." }
      ]
    },
    {
      "question": "47. Was gibt dieser Code aus?\n\n```python\n1: s = \"Python\"\n2: print(f\"{s} ist toll\")\n```",
      "options": [
        "`{s} ist toll`",
        "`s ist toll`",
        "`Python ist toll`",
        "SyntaxError"
      ],
      "answer": 2,
      "explanation": "Das `f` vor dem String aktiviert 'f-strings' (ab Python 3.6). Ausdrücke in geschweiften Klammern `{}` werden zur Laufzeit ausgewertet und eingefügt.",
      "weight": 1,
      "topic": "Python Syntax",
      "concept": "String Formatting",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "f-string", "definition": "Formatierter String-Literal zur Interpolation von Variablen." }
      ]
    },
    {
      "question": "48. Was ist das Problem bei diesem Dictionary-Zugriff?\n\n```python\n1: data = {'Name': 'Max', 'Alter': 25}\n2: print(data['Adresse'])\n```",
      "options": [
        "Es gibt `None` aus.",
        "Es wirft einen `KeyError`.",
        "Es gibt einen leeren String aus.",
        "Es wirft einen `IndexError`."
      ],
      "answer": 1,
      "explanation": "Der direkte Zugriff mit eckigen Klammern `[]` auf einen nicht existierenden Schlüssel wirft in Python einen `KeyError`. Die Methode `.get('Adresse')` würde stattdessen `None` zurückgeben.",
      "weight": 2,
      "topic": "Python Datenstrukturen",
      "concept": "Error Handling",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Sicherer Dictionary-Zugriff",
        "steps": [
          "Direktzugriff `data['key']`: Schnell, aber Fehler bei fehlendem Key.",
          "Methode `data.get('key')`: Sicher, liefert `None` (oder Default-Wert) bei fehlendem Key.",
          "Best Practice: Nutze `.get()`, wenn Unsicherheit über die Keys besteht."
        ],
        "content": "In Java Maps entspricht `.get()` eher dem sicheren Verhalten (gibt null zurück)."
      },
      "mini_glossary": [
        { "term": "KeyError", "definition": "Ausnahme, wenn ein Dictionary-Schlüssel nicht gefunden wird." }
      ]
    },
    {
      "question": "49. Welche Zeile verursacht einen `IndentationError`?\n\n```python\n1: for i in range(5):\n2: print(i)\n3:     print(\"Done\")\n```",
      "options": [
        "Zeile 1",
        "Zeile 2",
        "Zeile 3",
        "Keine, der Code ist korrekt."
      ],
      "answer": 1,
      "explanation": "In Python muss der Körper einer Schleife eingerückt sein. Zeile 2 steht auf derselben Ebene wie `for` und gehört somit syntaktisch nicht zur Schleife, was aber von `for` erwartet wird.",
      "weight": 1,
      "topic": "Python Syntax",
      "concept": "Indentation",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Scope", "definition": "Geltungsbereich von Variablen und Codeblöcken." }
      ]
    },
    {
      "question": "50. Sie wollen alle negativen Werte in einem NumPy-Array auf 0 setzen. Was macht dieser Code?\n\n```python\n1: import numpy as np\n2: arr = np.array([-1, 2, -3, 4])\n3: arr[arr < 0] = 0\n```",
      "options": [
        "Er setzt das gesamte Array auf 0, wenn irgendein Wert negativ ist.",
        "Er funktioniert korrekt und ändert `arr` zu `[0, 2, 0, 4]`.",
        "Er wirft einen Fehler, da Zuweisungen innerhalb von eckigen Klammern verboten sind.",
        "Er erzeugt eine Kopie, aber das Original `arr` bleibt unverändert."
      ],
      "answer": 1,
      "explanation": "Dies ist korrektes 'Boolean Masking' zur Zuweisung. `arr < 0` wählt die Indizes der negativen Werte aus, und die Zuweisung `= 0` ändert genau diese Stellen im Original-Array.",
      "weight": 2,
      "topic": "NumPy Operationen",
      "concept": "Conditional Assignment",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Maskierte Zuweisung",
        "steps": [
          "Maske erstellen: `[-1, 2, -3, 4] < 0` -> `[True, False, True, False]`.",
          "Indizierung: `arr[...]` wählt nur Elemente an Position 0 und 2.",
          "Zuweisung: Setze diese auf 0.",
          "Ergebnis: In-Place Modifikation."
        ],
        "content": "Dies ist viel effizienter als eine Schleife mit if-Bedingung."
      },
      "mini_glossary": [
        { "term": "In-Place", "definition": "Operation ändert die Daten direkt im Speicher, ohne neue Kopie." }
      ]
    },
    {
      "question": "51. Was ist das Ergebnis dieses Vergleichs?\n\n```python\n1: x = 0.1 + 0.2\n2: print(x == 0.3)\n```",
      "options": [
        "`True`",
        "`False`",
        "`0.30000000000000004`",
        "Fehler"
      ],
      "answer": 1,
      "explanation": "Aufgrund der IEEE 754 Gleitkomma-Darstellung ist 0.1 + 0.2 in binären Systemen minimal größer als 0.3 (etwa 0.30000000000000004). Der strikte Vergleich `==` schlägt daher fehl.",
      "weight": 3,
      "topic": "Numerik",
      "concept": "Floating Point Precision",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Gleitkomma-Ungenauigkeit",
        "steps": [
          "Problem: Binärsystem kann 0.1 nicht exakt darstellen (periodischer Bruch).",
          "Rechnung: Summe hat minimalen Rundungsfehler.",
          "Lösung: Nutzen Sie `np.isclose(x, 0.3)` oder prüfen Sie `abs(x - 0.3) < epsilon`."
        ],
        "content": "Dieses Problem existiert auch in Java (`double`), wird aber oft übersehen."
      },
      "mini_glossary": [
        { "term": "Epsilon", "definition": "Sehr kleine Zahl, die als Toleranzgrenze bei Vergleichen dient." }
      ]
    },
    {
      "question": "52. Warum schlägt dieser Code fehl?\n\n```python\n1: import numpy as np\n2: a = np.array([1, 2, 3])\n3: b = np.array([1, 2])\n4: print(a + b)\n```",
      "options": [
        "NumPy kann Arrays nicht addieren.",
        "ValueError: operands could not be broadcast together with shapes (3,) (2,).",
        "Er addiert die ersten zwei Elemente und ignoriert das dritte.",
        "Er füllt das kürzere Array mit Nullen auf."
      ],
      "answer": 1,
      "explanation": "NumPy Broadcasting funktioniert nur, wenn Dimensionen kompatibel sind (gleich groß oder eine Dimension ist 1). Länge 3 und Länge 2 sind inkompatibel.",
      "weight": 2,
      "topic": "NumPy Fehler",
      "concept": "Shape Mismatch",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Broadcasting Regeln",
        "steps": [
          "Regel: Dimensionen werden von rechts nach links verglichen.",
          "Check: Dim 3 vs Dim 2.",
          "Bedingung: Sind sie gleich? Nein. Ist eine davon 1? Nein.",
          "Folge: Fehler. NumPy rät nicht, wie aufgefüllt werden soll."
        ],
        "content": "Shape-Fehler sind die häufigsten Fehler beim Arbeiten mit neuronalen Netzen oder Matrix-Ops."
      },
      "mini_glossary": [
        { "term": "Shape", "definition": "Tupel, das die Größe der Dimensionen eines Arrays angibt." }
      ]
    },
    {
      "question": "53. Was passiert hier mit der Variable `x`?\n\n```python\n1: x = 10\n2: def change():\n3:     x = 20\n4: change()\n5: print(x)\n```",
      "options": [
        "Gibt `20` aus.",
        "Gibt `10` aus.",
        "Gibt Fehler 'UnboundLocalError'.",
        "Gibt `None` aus."
      ],
      "answer": 1,
      "explanation": "Innerhalb der Funktion `change` wird eine *neue lokale* Variable `x` erstellt (Shadowing). Die globale Variable `x` (Zeile 1) bleibt unverändert. Um global zu schreiben, müsste `global x` verwendet werden.",
      "weight": 2,
      "topic": "Python Scope",
      "concept": "Variable Scope",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Local vs Global Scope",
        "steps": [
          "Zeile 3: `x = 20` sieht aus wie eine Zuweisung.",
          "Python Regel: Zuweisungen im Funktionskörper erzeugen standardmäßig lokale Variablen.",
          "Effekt: Das äußere `x` wird überdeckt, aber nicht geändert.",
          "Resultat: `print(x)` greift auf das unveränderte äußere `x` zu."
        ],
        "content": "Scope-Regeln (LEGB: Local, Enclosing, Global, Built-in) sind essenziell für sauberen Code."
      },
      "mini_glossary": [
        { "term": "Shadowing", "definition": "Eine Variable in einem inneren Scope hat denselben Namen wie eine äußere und verdeckt diese." }
      ]
    },
    {
      "question": "54. Sie wollen eine Liste sortieren. Was ist der Unterschied zwischen diesen beiden Zeilen?\n\n```python\n1: l1 = [3, 1, 2]\n2: l2 = l1.sort()\n3: l3 = sorted(l1)\n```",
      "options": [
        "Kein Unterschied.",
        "`l1.sort()` sortiert in-place und gibt `None` zurück (l2 ist None). `sorted(l1)` erstellt eine neue sortierte Liste.",
        "`l1.sort()` ist veraltet, man sollte nur `sorted` nutzen.",
        "`sorted(l1)` sortiert in-place, `l1.sort()` nicht."
      ],
      "answer": 1,
      "explanation": "Listen-Methoden wie `.sort()`, `.append()`, `.reverse()` ändern das Objekt direkt und geben `None` zurück. Built-in Funktionen wie `sorted()` geben ein neues Objekt zurück.",
      "weight": 2,
      "topic": "Python Standard Library",
      "concept": "In-Place vs Return",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Rückgabewerte beachten",
        "steps": [
          "Fehlerquelle: `liste = liste.sort()` löscht die Liste (setzt sie auf None).",
          "Korrekt: `liste.sort()` (als Anweisung) ODER `neue_liste = sorted(liste)`.",
          "Java-Vergleich: `Collections.sort(list)` ist auch void/in-place."
        ],
        "content": "Wer `l2 = l1.sort()` schreibt, erlebt oft eine böse Überraschung."
      },
      "mini_glossary": [
        { "term": "Void", "definition": "Rückgabetyp, der anzeigt, dass eine Funktion keinen Wert liefert." }
      ]
    },
    {
      "question": "55. Was bewirkt der folgende Code zur Fehlerbehandlung?\n\n```python\n1: try:\n2:     x = 1 / 0\n3: except ZeroDivisionError:\n4:     x = 0\n5: else:\n6:     x = 1\n```",
      "options": [
        "`x` wird 0.",
        "`x` wird 1.",
        "Der Code stürzt ab.",
        "Der `else`-Block wird ausgeführt, bevor der Fehler auftritt."
      ],
      "answer": 0,
      "explanation": "Da `1/0` einen Fehler wirft, wird der `except`-Block ausgeführt (`x=0`). Der `else`-Block in einem try-Konstrukt wird nur ausgeführt, wenn *keine* Ausnahme auftrat.",
      "weight": 2,
      "topic": "Flow Control",
      "concept": "Try-Except-Else",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Der Else-Zweig in Try-Blöcken",
        "steps": [
          "Try: Versuche Code auszuführen.",
          "Exception: Fehler passiert -> Springe zu Except.",
          "Else: Kein Fehler passiert -> Führe Else aus.",
          "Finally (hier nicht gezeigt): Wird immer ausgeführt."
        ],
        "content": "`else` ist nützlich, um Code auszuführen, der nur bei Erfolg laufen soll, aber nicht mehr vom Error-Handling abgedeckt werden muss."
      },
      "mini_glossary": [
        { "term": "Exception Handling", "definition": "Strukturierter Umgang mit Laufzeitfehlern." }
      ]
    },
    {
      "question": "56. Ein häufiger Fehler beim Kopieren von Listen. Was gibt Zeile 4 aus?\n\n```python\n1: a = [1, 2, 3]\n2: b = a\n3: b[0] = 99\n4: print(a)\n```",
      "options": [
        "`[1, 2, 3]`",
        "`[99, 2, 3]`",
        "`[1, 2, 3, 99]`",
        "Fehler"
      ],
      "answer": 1,
      "explanation": "In Python sind Zuweisungen bei Objekten (wie Listen) nur Referenzkopien (Pointer). `a` und `b` zeigen auf denselben Speicher. Eine Änderung über `b` ist auch in `a` sichtbar.",
      "weight": 3,
      "topic": "Python Speicherverwaltung",
      "concept": "References",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Referenz vs Kopie",
        "steps": [
          "Zeile 2: `b = a` kopiert nur die Adresse, nicht die Daten.",
          "Analogie: Zwei Namensschilder an derselben Kiste.",
          "Lösung für echte Kopie: `b = a[:]` oder `b = a.copy()`."
        ],
        "content": "Dies ist identisch zu Java-Objekt-Referenzen, aber oft verwirrend für Anfänger bei simplen Datentypen."
      },
      "mini_glossary": [
        { "term": "Shallow Copy", "definition": "Kopie der Container-Struktur, Elemente bleiben Referenzen." }
      ]
    },
    {
      "question": "57. Sie nutzen `groupby` ohne eine Aggregationsfunktion. Was ist `res`?\n\n```python\n1: res = df.groupby('Kategorie')\n2: print(res)\n```",
      "options": [
        "Eine Fehlermeldung.",
        "Ein DataFrame, sortiert nach Kategorie.",
        "Ein `DataFrameGroupBy` Objekt (intermediate object).",
        "Eine Liste von DataFrames."
      ],
      "answer": 2,
      "explanation": "`groupby()` allein führt noch keine Berechnung durch. Es bereitet die Gruppierung vor (lazy evaluation) und gibt ein Zwischenobjekt zurück, auf das man `.sum()`, `.mean()` etc. anwenden muss.",
      "weight": 2,
      "topic": "Pandas API",
      "concept": "Lazy Evaluation",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Das GroupBy Objekt",
        "steps": [
          "Aufruf: `groupby` speichert nur das Mapping (welche Zeile gehört zu welcher Gruppe).",
          "Zweck: Warten auf Anweisung, was berechnet werden soll.",
          "Nutzung: Man kann darüber iterieren (`for name, group in res: ...`) oder aggregieren."
        ],
        "content": "Ein häufiger Anfängerfehler ist zu erwarten, dass `groupby` sofort eine Tabelle zurückgibt."
      },
      "mini_glossary": [
        { "term": "Lazy Evaluation", "definition": "Auswertung eines Ausdrucks erst dann, wenn das Ergebnis benötigt wird." }
      ]
    },
    {
      "question": "58. Welcher Fehler liegt hier vor?\n\n```python\n1: x, y = (10, 20, 30)\n```",
      "options": [
        "SyntaxError: Klammern fehlen.",
        "ValueError: too many values to unpack (expected 2).",
        "x wird 10, y wird 20, 30 wird ignoriert.",
        "x wird 10, y wird (20, 30)."
      ],
      "answer": 1,
      "explanation": "Dies ist 'Tuple Unpacking'. Die Anzahl der Variablen links (2) muss exakt mit der Anzahl der Elemente rechts (3) übereinstimmen, sonst gibt es einen `ValueError`.",
      "weight": 2,
      "topic": "Python Syntax",
      "concept": "Unpacking",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Unpacking Regeln",
        "steps": [
          "Prinzip: 1-zu-1 Zuordnung.",
          "Lösung 1: `x, y, z = ...` (3 Variablen).",
          "Lösung 2: `x, *y = ...` (y fängt den Rest als Liste auf -> `[20, 30]`)."
        ],
        "content": "Unpacking ist sehr elegant, erfordert aber strikte Übereinstimmung der Länge."
      },
      "mini_glossary": [
        { "term": "Unpacking", "definition": "Entpacken von Sequenzen in einzelne Variablen." }
      ]
    },
    {
      "question": "59. Was passiert bei diesem Import-Versuch?\n\n```python\n1: import pandas.DataFrame\n```",
      "options": [
        "Es importiert die Klasse DataFrame.",
        "Es funktioniert, wenn Pandas installiert ist.",
        "ModuleNotFoundError (oder ImportError), da DataFrame kein Modul, sondern eine Klasse in einem Paket ist.",
        "Es importiert alles aus Pandas."
      ],
      "answer": 2,
      "explanation": "Die Syntax `import package.module` erwartet, dass das letzte Element ein Modul (Datei/Ordner) ist. `DataFrame` ist eine Klasse. Korrekt wäre `from pandas import DataFrame`.",
      "weight": 1,
      "topic": "Python Imports",
      "concept": "Import Syntax",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Package", "definition": "Ordner mit Python-Modulen und einer `__init__.py`." }
      ]
    },
    {
      "question": "60. Sie möchten eine benutzerdefinierte Funktion auf jede Zeile eines DataFrames anwenden. Welches Argument fehlt oder ist falsch?\n\n```python\n1: def my_func(row):\n2:     return row['A'] + row['B']\n3:\n4: df['C'] = df.apply(my_func)\n```",
      "options": [
        "Nichts fehlt.",
        "Es muss `axis=1` angegeben werden, sonst iteriert `apply` über Spalten (axis=0).",
        "`my_func` darf keine Argumente haben.",
        "Pandas unterstützt keine benutzerdefinierten Funktionen."
      ],
      "answer": 1,
      "explanation": "Standardmäßig ist `axis=0` (Spalten). `apply` würde `my_func` eine ganze Spalte als Series übergeben. Da `my_func` aber `row['A']` (Zeilenzugriff) erwartet, crasht es. Mit `axis=1` wird zeilenweise iteriert.",
      "weight": 3,
      "topic": "Pandas Advanced",
      "concept": "Apply Axis",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Apply Richtung",
        "steps": [
          "Default: `apply` arbeitet vertikal (auf jeder Spalte).",
          "Ziel: Berechnung quer über Zeilen (Spalte A + Spalte B).",
          "Korrektur: `df.apply(my_func, axis=1)`.",
          "Hinweis: Oft langsam, besser direkt `df['A'] + df['B']` nutzen."
        ],
        "content": "Die Achsen-Logik ist bei `apply` genau umgekehrt zur Intuition mancher Nutzer ('axis=1' -> bewege dich entlang der Spaltenrichtung, also Zeile für Zeile)."
      },
      "mini_glossary": [
        { "term": "Row-wise", "definition": "Operation, die zeilenweise ausgeführt wird." }
      ]
    },
    {
      "question": "61. Welches Schlüsselwort fehlt, um über Schlüssel und Werte eines Dictionaries zu iterieren (analog zu `entrySet` in Java)?\n\n```python\n1: data = {'a': 1, 'b': 2}\n2: for k, v in data.__________:\n3:     print(k, v)\n```",
      "options": [
        "entries()",
        "items()",
        "keys()",
        "values()"
      ],
      "answer": 1,
      "explanation": "In Python liefert `.items()` die Schlüssel-Wert-Paare als Tupel zurück. `.entries()` existiert in Python nicht (das wäre Java-Jargon).",
      "weight": 1,
      "topic": "Python Datenstrukturen",
      "concept": "Dictionary Iteration",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "items()", "definition": "Methode, die eine Ansicht der (Key, Value)-Paare eines Dictionaries liefert." }
      ]
    },
    {
      "question": "62. Ergänzen Sie den ersten Parameter der Methode, der in Python explizit genannt werden muss (anders als `this` in Java).\n\n```python\n1: class Auto:\n2:     def __init__(__________, marke):\n3:         self.marke = marke\n```",
      "options": [
        "this",
        "self",
        "auto",
        "instance"
      ],
      "answer": 1,
      "explanation": "`self` ist die konventionelle Bezeichnung für die Instanzreferenz in Python. Sie muss als erster Parameter in jeder Instanzmethode definiert werden.",
      "weight": 1,
      "topic": "Python OOP",
      "concept": "Self Referenz",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "self", "definition": "Expliziter Parameter für die aktuelle Instanz (analog zu implizitem `this` in Java)." }
      ]
    },
    {
      "question": "63. Welcher Pandas-Befehl wird benötigt, um Zeilen mit fehlenden Werten zu entfernen?\n\n```python\n1: import pandas as pd\n2: df = pd.read_csv('data.csv')\n3: # Entferne Zeilen mit NaNs\n4: df_clean = df.__________()\n```",
      "options": [
        "delete_na",
        "remove_nulls",
        "dropna",
        "fillna"
      ],
      "answer": 2,
      "explanation": "`dropna()` ist die Standardmethode in Pandas, um Missing Values zu löschen. `fillna()` würde sie ersetzen.",
      "weight": 1,
      "topic": "Datenbereinigung",
      "concept": "Handling Missing Data",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "dropna", "definition": "Methode zum Entfernen von fehlenden Werten." }
      ]
    },
    {
      "question": "64. Vervollständigen Sie die List Comprehension.\n\n```python\n1: values = [1, 2, 3, 4]\n2: # Quadriere alle Werte\n3: squares = [x**2 __________ values]\n```",
      "options": [
        "for x in",
        "foreach x in",
        "in",
        "from x in"
      ],
      "answer": 0,
      "explanation": "Die Syntax einer List Comprehension lautet `[ausdruck for item in iterable]`. `foreach` gibt es in Python nicht.",
      "weight": 2,
      "topic": "Python Syntax",
      "concept": "List Comprehension",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Syntax-Aufbau",
        "steps": [
          "1. Was soll passieren? `x**2` (Ausdruck).",
          "2. Woher kommen die Daten? `for x in values` (Schleifenkopf).",
          "Zusammengesetzt: `[x**2 for x in values]`."
        ],
        "content": "List Comprehensions sind der 'pythonische' Weg, `.map()` oder Schleifen zu ersetzen."
      },
      "mini_glossary": [
        { "term": "Iterable", "definition": "Objekt, über das man iterieren kann (z.B. Liste, Range)." }
      ]
    },
    {
      "question": "65. Welches Statement sorgt für ein sicheres Datei-Handling (automatisches Schließen), ähnlich wie `try-with-resources` in Java?\n\n```python\n1: __________ open('datei.txt', 'r') as f:\n2:     content = f.read()\n```",
      "options": [
        "try",
        "using",
        "with",
        "scope"
      ],
      "answer": 2,
      "explanation": "Das `with`-Statement initiiert einen Context Manager, der sicherstellt, dass die Datei am Ende des Blocks geschlossen wird, auch wenn Fehler auftreten.",
      "weight": 2,
      "topic": "File I/O",
      "concept": "Context Manager",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Context Manager",
        "steps": [
          "Java: `try (BufferedReader br = ...) { ... }`",
          "Python: `with open(...) as f: ...`",
          "Funktion: Ruft automatisch `__exit__` (und damit `close`) auf."
        ],
        "content": "Verwenden Sie niemals `open()` ohne `with`, es sei denn, Sie haben einen sehr guten Grund."
      },
      "mini_glossary": [
        { "term": "Context Manager", "definition": "Objekt, das Ressourcenverwaltung (Setup/Teardown) übernimmt." }
      ]
    },
    {
      "question": "66. Sie wollen ein 1D-Array mit 9 Elementen in eine 3x3 Matrix umwandeln. Welcher NumPy-Befehl fehlt?\n\n```python\n1: import numpy as np\n2: arr = np.arange(9)\n3: mtx = arr.__________(3, 3)\n```",
      "options": [
        "resize",
        "reshape",
        "dim",
        "transform"
      ],
      "answer": 1,
      "explanation": "`.reshape(rows, cols)` ändert die Dimensionen eines Arrays, ohne die Daten zu ändern. Die Anzahl der Elemente muss konstant bleiben.",
      "weight": 1,
      "topic": "NumPy",
      "concept": "Reshaping",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Reshape", "definition": "Ändern der Form (Dimensionen) eines Arrays." }
      ]
    },
    {
      "question": "67. Welcher Code fehlt, um den Konstruktor der Elternklasse aufzurufen?\n\n```python\n1: class Tier:\n2:     def __init__(self, name): self.name = name\n3:\n4: class Hund(Tier):\n5:     def __init__(self, name, rasse):\n6:         __________(name) # Rufe Eltern-Init auf\n7:         self.rasse = rasse\n```",
      "options": [
        "super.__init__",
        "super().__init__",
        "Tier(name)",
        "this.super(name)"
      ],
      "answer": 1,
      "explanation": "In Python 3 nutzt man `super().__init__(arguments)`. Beachten Sie die Klammern nach `super`, die in Java nicht nötig sind, in Python aber eine Funktion aufrufen, die das Proxy-Objekt zurückgibt.",
      "weight": 3,
      "topic": "Python OOP",
      "concept": "Inheritance",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Super() in Python",
        "steps": [
          "Syntax: `super()` gibt ein temporäres Objekt der Elternklasse zurück.",
          "Aufruf: Darauf ruft man `.__init__` auf.",
          "Unterschied Java: Java ruft `super()` (Konstruktor) direkt auf; Python ruft die Methode `__init__` auf dem Super-Objekt."
        ],
        "content": "Dies ist essentiell für korrekte Vererbungsketten."
      },
      "mini_glossary": [
        { "term": "Super", "definition": "Built-in Funktion für den Zugriff auf Methoden der Elternklasse." }
      ]
    },
    {
      "question": "68. Vervollständigen Sie die Lambda-Funktion, um nach dem zweiten Element (Index 1) der Tupel zu sortieren.\n\n```python\n1: data = [('A', 10), ('B', 5), ('C', 20)]\n2: # Sortiere nach der Zahl\n3: data.sort(key=lambda x: __________)\n```",
      "options": [
        "x[0]",
        "x[1]",
        "x.get(1)",
        "x->1"
      ],
      "answer": 1,
      "explanation": "`x` ist hier ein Tupel, z.B. `('A', 10)`. Das zweite Element ist am Index 1. Also `x[1]`.",
      "weight": 2,
      "topic": "Python Funktionen",
      "concept": "Lambda Sort",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Lambda als Key",
        "steps": [
          "Input: Die `sort` Funktion übergibt jedes Element der Liste an `key`.",
          "Lambda: `lambda x: x[1]` nimmt das Tupel `x` und gibt den Wert an Index 1 zurück.",
          "Sortierung: Python sortiert die Liste basierend auf diesen Rückgabewerten (5, 10, 20)."
        ],
        "content": "In Java entspricht dies `Comparator.comparing(x -> x.get(1))`."
      },
      "mini_glossary": [
        { "term": "Key Argument", "definition": "Funktion, die für jedes Element einen Vergleichswert generiert." }
      ]
    },
    {
      "question": "69. Sie nutzen Matplotlib. Der Plot wurde konfiguriert, ist aber noch nicht sichtbar. Welcher Befehl fehlt am Ende?\n\n```python\n1: import matplotlib.pyplot as plt\n2: plt.plot([1, 2, 3], [4, 5, 6])\n3: __________\n```",
      "options": [
        "plt.render()",
        "plt.display()",
        "plt.show()",
        "plt.open()"
      ],
      "answer": 2,
      "explanation": "`plt.show()` ist der Befehl, um das Grafikfenster tatsächlich zu öffnen und den Plot zu rendern. In Jupyter Notebooks passiert dies oft automatisch, in Skripten ist es zwingend.",
      "weight": 2,
      "topic": "Visualisierung",
      "concept": "Plot Display",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Der Show-Befehl",
        "steps": [
          "Konfiguration: Alle `plt.plot`, `plt.title` etc. Befehle ändern den internen Status.",
          "Abschluss: `plt.show()` 'flusht' diesen Status auf den Bildschirm.",
          "Blockierend: In Skripten blockiert `show()` oft die Ausführung, bis das Fenster geschlossen wird."
        ],
        "content": "Ohne `show()` läuft das Skript durch, ohne dass Sie etwas sehen."
      },
      "mini_glossary": [
        { "term": "Backend", "definition": "Die Engine von Matplotlib, die die Pixel tatsächlich zeichnet (z.B. Qt, TkAgg)." }
      ]
    },
    {
      "question": "70. Welcher Operator fehlt, um zu prüfen, ob ein Element in einer Liste enthalten ist (Java: `contains`)?\n\n```python\n1: blacklist = [1, 5, 9]\n2: user_id = 5\n3: if user_id __________ blacklist:\n4:     print('Zugriff verweigert')\n```",
      "options": [
        "exists in",
        "contains",
        "in",
        "inside"
      ],
      "answer": 2,
      "explanation": "Der `in` Operator prüft auf Mitgliedschaft. Er funktioniert für Listen, Tupel, Sets, Dictionaries (Keys) und Strings.",
      "weight": 3,
      "topic": "Python Syntax",
      "concept": "Membership Operator",
      "cognitive_level": "Analysis",
      "extended_explanation": {
        "title": "Pythonic Membership Testing",
        "steps": [
          "Syntax: `x in container`.",
          "Rückgabe: `True` oder `False`.",
          "Performance: Bei Listen O(n), bei Sets/Dicts O(1).",
          "Lesbarkeit: Liest sich fast wie englischer Satz."
        ],
        "content": "Vermeiden Sie manuelle Schleifen zum Suchen, nutzen Sie `in`."
      },
      "mini_glossary": [
        { "term": "Membership Test", "definition": "Überprüfung, ob ein Wert Teil einer Kollektion ist." }
      ]
    },
    {
      "question": "71. Welches Schlüsselwort fehlt für die 'else if' Bedingung in Python?\n\n```python\n1: x = 10\n2: if x < 0:\n3:     print('Negativ')\n4: __________ x == 0:\n5:     print('Null')\n6: else:\n7:     print('Positiv')\n```",
      "options": [
        "else if",
        "elseif",
        "elif",
        "elsif"
      ],
      "answer": 2,
      "explanation": "Python kürzt `else if` strikt zu `elif` ab. `else if` (wie in Java) oder `elseif` (wie in PHP) verursachen einen Syntaxfehler.",
      "weight": 1,
      "topic": "Python Syntax",
      "concept": "Control Flow",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Control Flow", "definition": "Steuerung des Programmablaufs durch Bedingungen und Schleifen." }
      ]
    },
    {
      "question": "72. Welches Attribut nutzen Sie, um die Dimensionen (Zeilen, Spalten) eines DataFrames abzufragen (ohne Klammern, da es keine Methode ist)?\n\n```python\n1: import pandas as pd\n2: df = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\n3: # Ausgabe erwartet: (2, 2)\n4: print(df.__________)\n```",
      "options": [
        "size",
        "shape",
        "dim()",
        "length"
      ],
      "answer": 1,
      "explanation": "`.shape` ist ein Attribut (Property) von DataFrames und NumPy Arrays, das ein Tupel `(n_rows, n_cols)` liefert. Es wird ohne Klammern `()` aufgerufen.",
      "weight": 1,
      "topic": "Pandas API",
      "concept": "DataFrame Shape",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Attribute", "definition": "Eigenschaft eines Objekts, die ohne Klammern abgerufen wird." }
      ]
    },
    {
      "question": "73. Sie definieren eine Funktion, die noch nichts tun soll (Placeholder). Welches Schlüsselwort verhindert einen `IndentationError`?\n\n```python\n1: def todo_later():\n2:     __________\n```",
      "options": [
        "null",
        "continue",
        "pass",
        "void"
      ],
      "answer": 2,
      "explanation": "`pass` ist eine Anweisung, die nichts tut (No-Op). Sie wird benötigt, weil Python leere Blöcke (anders als `{}` in Java) syntaktisch nicht erlaubt.",
      "weight": 1,
      "topic": "Python Syntax",
      "concept": "Placeholder",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "pass", "definition": "Null-Operation; Platzhalter für syntaktisch notwendigen Code." }
      ]
    },
    {
      "question": "74. Welches Keyword entspricht dem Java-Wert `null`?\n\n```python\n1: result = fetch_data()\n2: if result is __________:\n3:     print('Keine Daten gefunden')\n```",
      "options": [
        "null",
        "Null",
        "nil",
        "None"
      ],
      "answer": 3,
      "explanation": "Das Python-Äquivalent zum Null-Referenztyp ist `None`. Es ist ein Singleton-Objekt und wird üblicherweise mit `is` geprüft.",
      "weight": 1,
      "topic": "Python Datentypen",
      "concept": "NoneType",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Singleton", "definition": "Klasse, von der nur eine einzige Instanz existieren kann." }
      ]
    },
    {
      "question": "75. Wie greifen Sie auf die Spaltennamen eines DataFrames zu?\n\n```python\n1: df = pd.read_csv('data.csv')\n2: # Liste alle Header auf\n3: headers = df.__________\n```",
      "options": [
        "keys()",
        "columns",
        "names",
        "header"
      ],
      "answer": 1,
      "explanation": "`df.columns` liefert ein Index-Objekt mit den Spaltennamen. `keys()` funktioniert auch, ist aber weniger explizit und eher für Dictionaries typisch.",
      "weight": 1,
      "topic": "Pandas API",
      "concept": "Column Access",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Index Object", "definition": "Unveränderliche Sequenz, die für Achsenbeschriftungen in Pandas genutzt wird." }
      ]
    },
    {
      "question": "76. Welches Wort fehlt, um zu prüfen, ob zwei Variablen auf *dasselbe* Objekt im Speicher zeigen (Referenzgleichheit)?\n\n```python\n1: a = [1, 2]\n2: b = a\n3: if a __________ b:\n4:     print('Identische Objekte')\n```",
      "options": [
        "==",
        "equals",
        "is",
        "same"
      ],
      "answer": 2,
      "explanation": "`is` prüft die Objekt-Identität (Speicheradresse), ähnlich wie `==` bei Objekten in Java. Der Operator `==` in Python prüft dagegen die Wertegleichheit (`equals()`).",
      "weight": 2,
      "topic": "Python Semantik",
      "concept": "Identity vs Equality",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "is vs ==",
        "steps": [
          "Vergleich `a == b`: Haben beide den gleichen Inhalt? (Value equality).",
          "Vergleich `a is b`: Sind es dieselben Speicheradressen? (Reference equality).",
          "Java-Analogie: Python `is` entspricht Java `==` (bei Objekten). Python `==` entspricht Java `.equals()`."
        ],
        "content": "Verwenden Sie `is` hauptsächlich für Singletons wie `None`."
      },
      "mini_glossary": [
        { "term": "Identity", "definition": "Eindeutige Kennung eines Objekts (meist Speicheradresse)." }
      ]
    },
    {
      "question": "77. Wie ermitteln Sie global die Länge einer Liste, eines Strings oder eines DataFrames?\n\n```python\n1: my_list = [10, 20, 30]\n2: count = __________(my_list)\n```",
      "options": [
        "my_list.length",
        "my_list.size()",
        "len",
        "count"
      ],
      "answer": 2,
      "explanation": "In Python ist `len()` eine Built-in Funktion, keine Methode des Objekts. Man ruft `len(obj)` auf, nicht `obj.len()`.",
      "weight": 1,
      "topic": "Python Built-ins",
      "concept": "Length Function",
      "cognitive_level": "Reproduction",
      "extended_explanation": null,
      "mini_glossary": [
        { "term": "Built-in", "definition": "Funktion, die in Python standardmäßig verfügbar ist ohne Import." }
      ]
    },
    {
      "question": "78. Welches Keyword entfernt ein Element aus einem Dictionary oder eine Variable aus dem Speicher?\n\n```python\n1: my_dict = {'a': 1, 'b': 2}\n2: __________ my_dict['a']\n3: # Jetzt enthält my_dict nur noch {'b': 2}\n```",
      "options": [
        "remove",
        "delete",
        "del",
        "erase"
      ],
      "answer": 2,
      "explanation": "`del` ist ein Statement, das Referenzen löscht. `del my_dict['a']` entfernt den Schlüssel 'a'.",
      "weight": 2,
      "topic": "Python Syntax",
      "concept": "Deletion",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Das del Statement",
        "steps": [
          "Dictionary: `del d['k']` löscht Key-Value-Paar.",
          "Liste: `del l[0]` löscht Element am Index.",
          "Variable: `del v` löscht den Variablennamen aus dem Scope."
        ],
        "content": "Alternativ gibt es oft `.pop()`, was den Wert vor dem Löschen noch zurückgibt."
      },
      "mini_glossary": [
        { "term": "Garbage Collection", "definition": "Automatische Speicherbereinigung ungenutzter Objekte." }
      ]
    },
    {
      "question": "79. Sie wollen Code zu Debugging-Zwecken validieren. Wenn die Bedingung falsch ist, soll ein Fehler fliegen.\n\n```python\n1: x = -5\n2: __________ x >= 0, 'x muss positiv sein'\n```",
      "options": [
        "check",
        "ensure",
        "test",
        "assert"
      ],
      "answer": 3,
      "explanation": "`assert condition, message` prüft eine Bedingung. Ist sie False, wird ein `AssertionError` mit der Nachricht geworfen. Wird oft für interne Konsistenzchecks genutzt.",
      "weight": 2,
      "topic": "Debugging",
      "concept": "Assertions",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Assertions nutzen",
        "steps": [
          "Zweck: Annahmen im Code sicherstellen.",
          "Syntax: `assert <Bedingung>, <Fehlermeldung>`.",
          "Verhalten: Wenn Bedingung True -> weiter. Wenn False -> Crash.",
          "Produktion: Kann mit `-O` Flag deaktiviert werden."
        ],
        "content": "In Java ähnlich wie `assert condition : message;`."
      },
      "mini_glossary": [
        { "term": "Assertion", "definition": "Aussage, die im Programmablauf als wahr angenommen wird." }
      ]
    },
    {
      "question": "80. Um ein Pandas DataFrame zu transponieren (Zeilen und Spalten tauschen), nutzen Sie welches Attribut?\n\n```python\n1: df = pd.DataFrame([[1, 2], [3, 4]])\n2: df_transposed = df.__________\n```",
      "options": [
        "transpose()",
        "T",
        "swapaxes()",
        "flip()"
      ],
      "answer": 1,
      "explanation": "`.T` ist der Kurz-Accessor (Property) für das Transponieren, analog zu NumPy-Matrizen. `.transpose()` existiert zwar als Methode, `.T` ist aber idiomatisch.",
      "weight": 2,
      "topic": "Pandas API",
      "concept": "Transposition",
      "cognitive_level": "Application",
      "extended_explanation": {
        "title": "Transponieren",
        "steps": [
          "Ausgang: Zeilen sind Beobachtungen, Spalten sind Features.",
          "Ziel: Features sollen Zeilen sein.",
          "Code: `df.T` spiegelt den DataFrame an der Hauptdiagonalen.",
          "Typ: Datentypen können sich ändern, wenn Spalten nicht uniform waren."
        ],
        "content": "Häufig nötig, um Daten für bestimmte Plots oder Algorithmen vorzubereiten."
      },
      "mini_glossary": [
        { "term": "Transponierte Matrix", "definition": "Matrix, die durch Vertauschen von Zeilen und Spalten entsteht." }
      ]
    }
  ]
}